/**
 * @file driver.cpp
 * @author Emanuel Buttaci
 * This file is the entry point of the nemesis compiler which executes the driver
 * 
 */
#include <cstring>
#include <fstream>
#include <iostream>
#include <sstream>


#include "nemesis/driver/driver.hpp"
#include "nemesis/tokenizer/tokenizer.hpp"
#include "nemesis/parser/parser.hpp"
#include "nemesis/pm/pm.hpp"
#include "nemesis/analysis/checker.hpp"
#include "nemesis/codegen/code_generator.hpp"

namespace nemesis {
    namespace impl {
        // exit codes with special meaning
        struct exit {
            // in general success
            static constexpr int success = 0;
            // in general failure, missing arguments 
            // or invalid options or compilation failure
            static constexpr int failure = 1;
        };
    
        bool check_file_name_extension(const char* name)
        {
            size_t len = std::strlen(name);
            const char* ptr = name + len - 1;

            for (; ptr >= name && *ptr != '.'; --ptr);
            // if there's no extension or if there is no file name before `.`
            if (ptr <= name) return false;
            // now pos points to the first character after `.` which is beginning of extension
            ++ptr;
            // checks that extension is `ns`
            return name + len - ptr == 2 && *ptr == 'n' && *(ptr + 1) == 's';
        }

        std::string tokens_to_string(const tokenizer::tokens& tokens)
        {
            std::ostringstream oss;
            auto it = tokens.begin(), end = tokens.end();
            
            oss << "here's your damned tokens:\n";
            --end;

            while (it != end) {
                oss << "  â”œâ”€> " << it->description() << "\n";
                ++it;
            }
            
            oss << "  â””â”€> " << it->description() << "\n";

            return oss.str();
        }

        std::string ast_to_string(utf8::span file, ast::pointer<ast::statement> ast)
        {
            std::ostringstream oss;
            
            oss << "this is your goddamned abstract syntax tree for file `" << file << "`\n" << ast::printer().print(*ast);

            return oss.str();
        }
    }

    bool Driver::options::is(kind k) const { return bits_ & static_cast<unsigned>(k); }

    void Driver::options::set(kind k) { bits_ |= static_cast<unsigned>(k); }

    void Driver::options::clear(kind k) { bits_ &= ~static_cast<unsigned>(k); }

    unsigned Driver::options::raw() const { return bits_; }

    const char Driver::usage[] = "usage: nemesis <command> [options]";

    const char Driver::description[] = "description: Hi b*tch, this is Nemesis compiler and package manager";
    
    const char Driver::help[] = "commands:\n"
                                "    init:                    initializes workspace (app or library) creating manifest and lockfile\n"
                                "    add <lib> <version>:     installs a dependency library inside current workspace\n"
                                "    remove <lib> <version>:  uninstalls a dependency library from current workspace\n"
                                "    build:                   builds current workspace as an app or library using information from lockfile\n"
                                "    run [options]:          builds and runs current app if any\n"
                                "    test:                    executes all library test in the same order in which they are declared"
                                "options:\n"
                                "    -tokens:       prints tokens generated by the tokenizer\n"
                                "    -ast:          prints abstract syntax tree generated by the parser and semantic analyzer\n"
                                "    -trace:        dumps stack trace if program crashes\n"
                                "    -args:         specify runtime arguments for program to be run\n"
                                "    -help:         prints information about options";

    void Driver::parse_arguments(int argc, char **argv)
    {
        // first of all it parses command
        if (argc == 1) {
            diagnostic_publisher_.publish(diagnostic::builder().severity(diagnostic::severity::error).message("You can't invoke Nemesis compiler without any command, b*tch!").build());
            exit_code_ = impl::exit::failure;
        }
        else if (std::strcmp("init", argv[1]) == 0) command_ = command::initialize;
        else if (std::strcmp("add", argv[1]) == 0) command_ = command::add;
        else if (std::strcmp("remove", argv[1]) == 0) command_ = command::remove;
        else if (std::strcmp("build", argv[1]) == 0) command_ = command::build;
        else if (std::strcmp("clean", argv[1]) == 0) command_ = command::clean;
        else if (std::strcmp("run", argv[1]) == 0) command_ = command::run;
        else if (std::strcmp("test", argv[1]) == 0) command_ = command::test;
        else {
            diagnostic_publisher_.publish(diagnostic::builder().severity(diagnostic::severity::error).message(diagnostic::format("I've never heard of command `$` before, idiot.", argv[1])).build());
            exit_code_ = impl::exit::failure;
        }
        // stops parsing on failure
        if (exit_code_ == impl::exit::failure) return;
        // parse command arguments and set options and source files
        for (auto i = 1; i < argc; ++i) {
            if (std::strcmp("-help", argv[i]) == 0) {
                options_.set(options::kind::help);
            }
            else if (std::strcmp("-tokens", argv[i]) == 0) {
                options_.set(options::kind::tokens);
            }
            else if (std::strcmp("-ast", argv[i]) == 0) {
                options_.set(options::kind::ast);
            }
            else if (std::strcmp("-trace", argv[i]) == 0) {
                options_.set(options::kind::trace);
            }
            else if (std::strcmp("-args", argv[i]) == 0) {
                for (auto j = i + 1; j < argc; ++j) runtime_args_.push_back(argv[j]);
                break;
            }
            else if (argv[i][0] == '-') {
                error("can you tell me what the hell this `$` option mean?", argv[i]);
                exit_code_ = impl::exit::failure;
            }
        }
    }

    Driver::Driver(int argc, char **argv, diagnostic_publisher& diagnostic_publisher) :
        exit_code_(impl::exit::success),
        options_(),
        pathname_(argv[0]),
        source_handler_(source_handler::instance()),
        diagnostic_publisher_(diagnostic_publisher)
    {
        parse_arguments(argc, argv);
    }

    Driver::command Driver::get_command() const { return command_; }

    Driver::options Driver::get_options() const { return options_; }

    utf8::span Driver::pathname() const { return pathname_; }
    
    source_handler& Driver::get_source_handler() const { return const_cast<source_handler&>(source_handler_); }
    
    diagnostic_publisher& Driver::get_diagnostic_publisher() const { return const_cast<diagnostic_publisher&>(diagnostic_publisher_); }
    
    int Driver::run() try
    {
        // commands has been invoked illegally, so usage is displayed
        if (exit_code_ != impl::exit::success) message(usage);
        // command has been invoked correctly so it is executed
        else if (command_ == command::initialize) init();
        else if (command_ == command::build) build();
        else if (command_ == command::clean) clean();
        else throw std::invalid_argument("command not yet implemented");

        if (exit_code_ == impl::exit::success) message("Success! All went fine. Happy coding, brother! ðŸ¤Ÿ");
        else if (exit_code_ == impl::exit::failure) message("F*ck... I couldn't do anything to save you from failure. ðŸ˜­");
        
        return exit_code_;
    }
    catch (pm::exception&) { 
        return (exit_code_ = impl::exit::failure); 
    }

    void Driver::init()
    {
        char input;
        message("Welcome to the Nemesis gang, brother!");
        message("Now I'm gonna ask you some questions before we get started...");
        // error code for file system operations
        std::error_code code;
        // first of all tests if there is any configuration present
        if (std::filesystem::exists(pm::manager::manifest_path, code)) {
            do { question("I noticed you have already some configuration. Do you wanna preserve it? (y/n) ", input); }
            while (input != 'y' && input != 'n' && input != 'Y' && input != 'N');
            // if user wants to preserve previous configuration, then we can exit now
            if (input == 'y' || input == 'Y') {
                message("Good then, don't forget to place your Nemesis source files inside `$` directory and C++ files inside `$` directory", pm::manager::sources_path, pm::manager::cpp_sources_path);
                return;
            }
        }
        // application or library choice
        do { question("Are you gonna develop an application? If no, I assume you're gonna build a library. (y/n)", input); }
        while (input != 'y' && input != 'n' && input != 'Y' && input != 'N');
        // user chooses application
        if (input == 'y' || input == 'Y') {
            std::string name;
            // asks info about name
            do { question("How are you gonna name your application?", name); }
            while (!pm::is_valid_package_name(name));
            // creates manifest file
            std::ofstream manifest(pm::manager::manifest_path);
            
            if (!manifest) {
                error("I have some problems creating file `$` in current workspace, f*ck...", pm::manager::manifest_path);
                exit_code_ = impl::exit::failure;
                return;
            }
            // adds application information
            manifest << "@application\nname '" << name << "'\nversion '1.0.0'\n";
            // adds standard library
            manifest << "@dependencies\ncore\n";
            // create directories for sources
            std::filesystem::create_directory(pm::manager::sources_path, code);
            // creates source file for entry point of application only if it doesn't exist
            if (!std::filesystem::exists(std::string(pm::manager::sources_path) + "/start.ns", code)) {
                std::ofstream appfile(std::string(pm::manager::sources_path) + "/start.ns");
                // write basic application template
                appfile << "app " << name << "\n\nstart(args: [chars]) {\n    println(\"Surprise motherfucker!\")\n}";
            }
        }
        // user chooses library
        else {
            std::string name, version;
            // asks info about name
            do { question("How are you gonna name your library?", name); }
            while (!pm::is_valid_package_name(name));
            // asks info about version
            do { question("Which version are you building?", version); }
            while (!pm::is_valid_package_version(version));
            // creates manifest file
            std::ofstream manifest(pm::manager::manifest_path);
            
            if (!manifest) {
                error("I have some problems creating file `nemesis.manifest` in current workspace, f*ck...");
                exit_code_ = impl::exit::failure;
                return;
            }
            // adds library information
            manifest << "@library\nname '" << name << "'\nversion '" << version << "'\n";
            // adds standard library
            manifest << "@dependencies\ncore\n";
            // create directories for sources
            std::filesystem::create_directory(pm::manager::sources_path, code);
        }
        // create directories for sources and dependencies
        std::filesystem::create_directory(pm::manager::cpp_sources_path, code);
        std::filesystem::create_directory(pm::manager::dependencies_path, code);
        // exits
        message("Good then, don't forget to place your Nemesis source files inside `$` directory and C++ files inside `$` directory", pm::manager::sources_path, pm::manager::cpp_sources_path);
    }

    void Driver::build() 
    {
        // package manager instance
        pm::manager manager(diagnostic_publisher_, source_handler_);
        // error code for file system operations
        std::error_code code;
        // first checks if workspace is properly initialized
        if (!std::filesystem::exists(pm::manager::manifest_path, code) || !std::filesystem::exists(pm::manager::sources_path, code)) {
            error("it looks like you haven't properly initialized your workspace, dammit!");
            message("Try running `$ init` to configure your application or library, brother. See you soon!", pathname_);
            exit_code_ = impl::exit::failure;
            return;
        }
        // retrieve information from current manifest file
        pm::manifest manifest;
        message("Reading information from `nemesis.manifest`...");
        // operation may fail, so entire compilation fails then
        try {
            manifest = manager.parse_manifest_file(pm::manager::manifest_path);
        }
        catch (pm::exception&) {
            exit_code_ = impl::exit::failure;
            return;
        }
        // two scenarios
        // i. 'nemesis.lock' exists, so we parse it and compile from its information
        // ii. `nemesis.lock' does not exists yet, so it is generate from manifest file building dependency tree
        pm::lock lock;
        // check if it exists
        if (std::filesystem::exists(pm::manager::lock_path)) {
            // retrieve information from current lock file
            message("Reading information from `$`...", pm::manager::lock_path);
            // operation may fail, so entire compilation fails then
            try {
                lock = manager.parse_lock_file(pm::manager::lock_path);
            }
            catch (pm::exception&) {
                exit_code_ = impl::exit::failure;
                return;
            }
        }
        else {
            // generates lock file from manifest file
            message("Generating `$`...", pm::manager::lock_path);
            // operation may fail, so entire compilation fails then
            try {
                // generation requires building the dependency tree
                lock = manager.generate_lock_file(manifest, pm::manager::lock_path);
            }
            catch (pm::exception&) {
                exit_code_ = impl::exit::failure;
                return;
            }
        }
        // building starts with information
        message("Let's build your $`$`...", manifest.kind == pm::manifest::kind::app ? "application " : manifest.kind == pm::manifest::kind::lib ? "library " : "", manifest.name);
        // constructs compilation from lock file
        auto compilation = manager.build_compilation_chain(lock);
        // for each source file
        // i) it extracts all its tokens
        // ii) builds its syntax tree
        for (auto source : source_handler_.sources()) {
            source_file& file = *source.second;
            // extraction of tokens
            tokenizer::tokens tokens;
            tokenizer tokenizer(file, diagnostic_publisher_);
            tokenizer.tokenize(tokens);
            // tokens are printed if option '-tokens' is specified
            if (options_.is(options::kind::tokens)) message(impl::tokens_to_string(tokens));
            // construction of syntax tree associated to current file
            parser parser(tokens, file, diagnostic_publisher_);
            if (auto ast = parser.parse()) {
                file.ast(ast);
                // if option '-ast' is specified then the syntax tree is printed for all sources
                if (options_.is(options::kind::ast)) message(impl::ast_to_string(file.name(), ast));
            }
        }
        // semantic checking is performed on all packages, so from all source files are costructed workspaces
        // and definitions inside those are fully analyzed and annotated
        checker checker(compilation);
        checker.Check();
        // if errors were detected, then we exit with failure without code generation
        if (diagnostic_publisher_.errors() > 0) {
            message("Compilation failed due to $ damned errors of yours!", diagnostic_publisher_.errors());
            exit_code_ = impl::exit::failure;
            return;
        }
        // no errors so far, we can proceed with code generation, which shouldn't give errors if cpp sources are correct
        code_generator codegen(checker);
        // trace option will slow down resulting program
        codegen.trace(options_.is(options::kind::trace));
        // generation is launched
        auto targets = codegen.generate();
        // now compile all targets files and cpp source files to cpp files
        if (compilation.build(targets)) exit_code_ = impl::exit::success;
        else exit_code_ = impl::exit::failure;
    }

    void Driver::clean()
    {
        // error code for file system operations
        std::error_code code;
        // log
        message("I'm gonna remove all build trash left in this damned workspace, pal...");
        // to clean workspace we just need to remove lockfile `nemesis.lock` which contains information about build chain
        std::filesystem::remove(pm::manager::lock_path, code);
        // remove executable if generated
        if (std::filesystem::exists(pm::manager::executable_path, code)) std::filesystem::remove(pm::manager::executable_path, code);
        // all correct
        exit_code_ = impl::exit::success;
    }
}

int main(int argc, char **argv)
{
    // creates shared publisher and printer
    nemesis::diagnostic_publisher publisher;
    nemesis::diagnostic_printer printer(std::cout);
    // connects printer to the publisher
    publisher.attach(printer);
    // driver is created with executable arguments
    nemesis::Driver driver(argc, argv, publisher);
    
    try {
        return driver.run();
    }
    catch (std::string& e) {
        std::cout << e;
        return nemesis::impl::exit::failure;
    }
}