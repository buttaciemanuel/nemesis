/**
 * @file driver.cpp
 * @author Emanuel Buttaci
 * This file is the entry point of the nemesis compiler which executes the driver
 * 
 */
#include <cstring>
#include <fstream>
#include <iostream>
#include <sstream>

#include "nemesis/driver/driver.hpp"
#include "nemesis/driver/compilation.hpp"
#include "nemesis/tokenizer/tokenizer.hpp"
#include "nemesis/parser/parser.hpp"
#include "nemesis/analysis/checker.hpp"
#include "nemesis/codegen/code_generator.hpp"

namespace nemesis {
    namespace impl {
        // exit codes with special meaning
        struct exit {
            // in general success
            static constexpr int success = 0;
            // in general failure, missing arguments 
            // or invalid options or compilation failure
            static constexpr int failure = 1;
        };
    
        bool check_file_name_extension(const char* name)
        {
            size_t len = std::strlen(name);
            const char* ptr = name + len - 1;

            for (; ptr >= name && *ptr != '.'; --ptr);
            // if there's no extension or if there is no file name before `.`
            if (ptr <= name) return false;
            // now pos points to the first character after `.` which is beginning of extension
            ++ptr;
            // checks that extension is `ns`
            return name + len - ptr == 2 && *ptr == 'n' && *(ptr + 1) == 's';
        }
    }

    int compilation::compile(std::string output)
    {
        std::string command = "g++ -std=c++14 -lm";
        // link builtin files
        for (struct compilation::source source : builtins) {
            // concat file path
            command.append(" ").append(source.path);
        }
        // first round is for creating C/C++ source files
        for (struct compilation::source source : sources) {
            // creates the file
            std::ofstream outfile(source.path.data());
            // prints its content
            outfile << source.content;
            // concat file path
            command.append(" ").append(source.path);
        }
        // adds output file
        command += " -o " + output;
        // save exit status
        int status = system(command.data());
        // remove all sources except for builtins
        for (struct compilation::source source : sources) remove(source.path.data());
        // second round is for running compilation command
        if (status != 0) {
            publisher_.publish(diagnostic::builder().severity(diagnostic::severity::error).message("some errors occurred when compiling source files, this is extremely weird, f*ck...").build());
            return impl::exit::failure;
        }
        // success
        publisher_.publish(diagnostic::builder().severity(diagnostic::severity::none).message("compilation success, mate!").build());
        // exit with success
        return impl::exit::success;
    }

    int compilation::run(std::vector<const char*> args)
    {
        // first of it builds source files
        int status = compile("examples/a.out");
        // exit without running on failure
        if (status != 0) return impl::exit::failure;
        // success
        publisher_.publish(diagnostic::builder().severity(diagnostic::severity::none).message("launching your app, three, two, one...").build());
        // runs with arguments if any
        std::ostringstream command;
        command << "examples/a.out";
        for (const char* arg : args) command << " " << arg;
        status = system(command.str().data());
        // remove output file
        remove("examples/a.out");
        // exit on failure
        if (status != 0) return impl::exit::failure;
        // exit with success
        return impl::exit::success;
    }

    bool driver::options::is(kind k) const { return bits_ & static_cast<unsigned>(k); }

    void driver::options::set(kind k) { bits_ |= static_cast<unsigned>(k); }

    void driver::options::clear(kind k) { bits_ &= ~static_cast<unsigned>(k); }

    unsigned driver::options::raw() const { return bits_; }

    const char driver::usage[] = "usage: nemesis [options] files ...";

    const char driver::description[] = "description: Hi b*tch, this is Nemesis compiler";
    
    const char driver::help[] = "options:\n"
                                "    --tokens:       prints tokens generated by the tokenizer\n"
                                "    --ast:          prints abstract syntax tree generated by the parser and semantic analyzer\n"
                                "    --compile:      compiles files without running the program\n"
                                "    --trace:        dumps stack trace if program crashes\n"
                                "    --args:         specify runtime arguments for program to be run without compile option\n"
                                "    --help:         prints information about options";

    const char* driver::builtin_files[] = { "libns/builtin.ns" };

    void driver::parse_arguments(int argc, char **argv)
    {
        unsigned files = 0;
        // parse command arguments and set options and source files
        for (auto i = 1; i < argc; ++i) {
            if (std::strcmp("--help", argv[i]) == 0) {
                options_.set(options::kind::help);
            }
            else if (std::strcmp("--tokens", argv[i]) == 0) {
                options_.set(options::kind::tokens);
            }
            else if (std::strcmp("--ast", argv[i]) == 0) {
                options_.set(options::kind::ast);
            }
            else if (std::strcmp("--compile", argv[i]) == 0) {
                options_.set(options::kind::compile);
            }
            else if (std::strcmp("--trace", argv[i]) == 0) {
                options_.set(options::kind::trace);
            }
            else if (std::strcmp("--args", argv[i]) == 0) {
                for (auto j = i + 1; j < argc; ++j) runtime_args_.push_back(argv[j]);
                break;
            }
            else if (argv[i][0] == '-') {
                diagnostic diag = diagnostic::builder()
                    .severity(diagnostic::severity::error)
                    .message(diagnostic::format("Can you tell me what the hell this `$` option mean?", argv[i]))
                    .build();
                
                diagnostic_publisher_.publish(diag);
                exit_code_ = impl::exit::failure;
            }
            else {
                // wrong file extension
                if (!impl::check_file_name_extension(argv[i])) {
                    diagnostic diag = diagnostic::builder()
                                .severity(diagnostic::severity::error)
                                .message(diagnostic::format("I will only compile files with `.ns` extension and file `$` is not one of those, idiot!", argv[i]))
                                .build();

                    diagnostic_publisher_.publish(diag);
                    exit_code_ = impl::exit::failure;
                }
                // if source file argument is provided then it is opened for reading its content
                // if source file cannot be read then compilation process fails
                else if (!source_handler_.load(utf8::span(argv[i]))) {
                    diagnostic diag = diagnostic::builder()
                        .severity(diagnostic::severity::error)
                        .message(std::string("There's no damn way I can open file `").append(argv[i]).append("`."))
                        .build();

                    diagnostic_publisher_.publish(diag);
                    exit_code_ = impl::exit::failure;
                }

                ++files;
            }
        }
        // --help option can be whened without source file argument
        // otherwise source file argument is necessary
        if (files == 0 && !options_.is(options::kind::help)) {
            diagnostic diag = diagnostic::builder()
                        .severity(diagnostic::severity::error)
                        .message("What the heck am I supposed to compile if you don't pass any file?!")
                        .build();

            diagnostic_publisher_.publish(diag);
            exit_code_ = impl::exit::failure;
        }
        // loading of standard library
        for (auto pathname : builtin_files) {
            // loads standard library
            if (!source_handler_.load(utf8::span(pathname))) {
                diagnostic diag = diagnostic::builder()
                    .severity(diagnostic::severity::error)
                    .message(diagnostic::format("There's no damn way I can open library file `$`.", pathname))
                    .build();

                diagnostic_publisher_.publish(diag);
                exit_code_ = impl::exit::failure;
            }
            // sets file as builtin
            else source_handler_.get(utf8::span(pathname)).builtin(true);
        }
    }

    driver::driver(int argc, char **argv, diagnostic_publisher& diagnostic_publisher) :
        exit_code_(impl::exit::success),
        options_(),
        pathname_(argv[0]),
        source_handler_(source_handler::instance()),
        diagnostic_publisher_(diagnostic_publisher)
    {
        parse_arguments(argc, argv);
    }


    driver::options driver::get_options() const { return options_; }

    utf8::span driver::pathname() const { return pathname_; }
    
    source_handler& driver::get_source_handler() const { return const_cast<source_handler&>(source_handler_); }
    
    diagnostic_publisher& driver::get_diagnostic_publisher() const { return const_cast<diagnostic_publisher&>(diagnostic_publisher_); }
    
    namespace impl {
        std::string tokens_to_string(const tokenizer::tokens& tokens)
        {
            std::ostringstream oss;
            auto it = tokens.begin(), end = tokens.end();
            
            oss << "here's your damned tokens:\n";
            --end;

            while (it != end) {
                oss << "  ├─> " << it->description() << "\n";
                ++it;
            }
            
            oss << "  └─> " << it->description() << "\n";

            return oss.str();
        }

        std::string ast_to_string(utf8::span file, ast::pointer<ast::statement> ast)
        {
            std::ostringstream oss;
            
            oss << "this is your goddamned abstract syntax tree for file `" << file << "`\n" << ast::printer().print(*ast);

            return oss.str();
        }
    }

    int driver::run()
    {
        // commands has been invoked illegally, so usage is displayed
        if (exit_code_ != impl::exit::success) {
            diagnostic diag = diagnostic::builder()
                .severity(diagnostic::severity::none)
                .message(usage)
                .build();
            
            diagnostic_publisher_.publish(diag);
        }
        // command has been invoked correctly so it is executed
        else {
            // prints help information and then exit
            if (options_.is(options::kind::help)) {
                auto builder = diagnostic::builder().severity(diagnostic::severity::none).message(description);
                
                diagnostic_publisher_.publish(builder.build());
                builder.message(usage);
                diagnostic_publisher_.publish(builder.build());
                builder.message(help);
                diagnostic_publisher_.publish(builder.build());
            }
            
            // if exit code is zero compiles all source files
            if (exit_code_ == impl::exit::success) {
                // root for all nucleuses
                std::unordered_map<std::string, ast::pointer<ast::nucleus>> root;
                // semantic checker
                checker checker(root, source_handler_, diagnostic_publisher_);
                // compilation of all source files
                for (auto pair : source_handler_.sources()) {
                    source_file& file = *(pair.second);
                    
                    diagnostic diag = diagnostic::builder()
                                    .severity(diagnostic::severity::none)
                                    .message(diagnostic::format("compiling file `$` ...", file.name().cdata()))
                                    .build();

                    diagnostic_publisher_.publish(diag);
                
                    tokenizer::tokens tokens;
                    tokenizer tokenizer(file, diagnostic_publisher_);

                    tokenizer.tokenize(tokens);

                    // print tokens option specified
                    if (options_.is(options::kind::tokens)) {
                        auto builder = diagnostic::builder()
                                       .severity(diagnostic::severity::none)
                                       .message(impl::tokens_to_string(tokens));

                        diagnostic_publisher_.publish(builder.build());
                    }

                    parser parser(tokens, file, diagnostic_publisher_);

                    if (auto ast = parser.parse()) file.ast(ast);
                }
                // semantic checking
                checker.check();
                // ast dumping
                if (options_.is(options::kind::ast)) {
                    for (auto source : source_handler_.sources()) {
                        diagnostic_publisher_.publish(diagnostic::builder().severity(diagnostic::severity::none).message(impl::ast_to_string(source.first, std::dynamic_pointer_cast<ast::statement>(source.second->ast()))).build());
                    }
                }
                // if errors were detected, then we exit with failure
                if (diagnostic_publisher_.errors() > 0) {
                    diagnostic_publisher_.publish(diagnostic::builder().severity(diagnostic::severity::none).message(diagnostic::format("compilation failed due to $ damned errors of yours!", diagnostic_publisher_.errors())).build());
                    return (exit_code_ = impl::exit::failure);
                }
                // otherwise generates code for compilation
                code_generator codegen(root, checker.scopes(), diagnostic_publisher_, code_generator::kind::CPP);
                codegen.set_entry_point(checker.entry_point());
                codegen.trace(options_.is(options::kind::trace));
                compilation compilation = codegen.generate();
                // complete compilation checking for errors and just compile without running
                if (options_.is(options::kind::compile)) exit_code_ = compilation.compile();
                // otherwise it compiles and run process
                else exit_code_ = compilation.run(runtime_args_);
            }
        }

        return exit_code_;
    }
}

int main(int argc, char **argv)
{
    // creates shared publisher and printer
    nemesis::diagnostic_publisher publisher;
    nemesis::diagnostic_printer printer(std::cout);
    // connects printer to the publisher
    publisher.attach(printer);
    // driver is created with executable arguments
    nemesis::driver driver(argc, argv, publisher);
    
    try {
        return driver.run();
   }
    catch (std::string& e) {
        std::cout << e;
        return nemesis::impl::exit::failure;
    }
}