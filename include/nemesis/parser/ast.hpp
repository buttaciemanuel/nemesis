/**
 * @file ast.hpp
 * @author Emanuel Buttaci
 * This file contains node types for abstract syntax tree
 * generated by the parser
 */
#ifndef AST_HPP
#define AST_HPP

#include <list>
#include <sstream>
#include <memory>

#include "utils/safe.hpp"
#include "nemesis/source/source.hpp"
#include "nemesis/tokenizer/token.hpp"

namespace nemesis {
    class environment;
    struct substitution;
    namespace ast {
        class expression;
        class statement;
        class declaration;
        class type;
        struct visitor;
        struct workspace;
        /**
         * A path is a sequence of names which represent a declaration
         * name with absolute path.
         * 
         * For example, 'ns.core.random', 'VariantType.Kind'
         */
        using path = std::vector<token>;
        /**
         * Converts a path into a string
         * @param p Path
         * @return String path where names are divided by dots
         */
        std::string path_to_string(const ast::path& p);
        /**
         * Gets the source range of the path name
         * @param p Path
         * @return Source range of path name
         */
        source_range range_of_path(const ast::path& p);
        /**
         * Shared pointer for memory management for the abstract syntax tree
         * 
         * @tparam T Tree node type
         */
        template<typename T>
        using pointer = std::shared_ptr<T>;
        /**
         * Vector of ast pointers
         * 
         * @tparam T Tree node type
         */
        template<typename T>
        using pointers = std::vector<pointer<T>>;
        /**
         * Allocate a node and returns its smart pointer
         * 
         * @tparam T Node type
         * @tparam Args Node constructor parameters types
         * @param args Node constructor arguments
         * @return Smart pointer
         */
        template<typename T, typename... Args>
        pointer<T> create(Args&&... args)
        {
            return pointer<T>(new T(std::forward<Args>(args)...));
        }
    }

    struct constval {
        friend class evaluator;
        using character = codepoint;
        using integer = utils::safe_signed_int;
        using uinteger = utils::safe_unsigned_int;
        using real = utils::safe_float;
        using rational = utils::safe_rational;
        using complex = utils::safe_complex;
        using string = std::string;
        using sequence = std::vector<constval>;

        constval();

        constval(const constval& other) : type(other.type), s(other.s), seq(other.seq)
        {
            constexpr size_t offset = sizeof(type) + sizeof(s) + sizeof(seq);
            std::memcpy(reinterpret_cast<char*>(this) + offset, reinterpret_cast<const char*>(&other) + offset, sizeof(constval) - offset);
        }

        size_t hash() const;

        ~constval() {}
        std::string str() const;
        std::string description() const;
        std::string simple() const;

        ast::pointer<ast::type> type;
        string s;
        sequence seq;
        union {
            character ch;
            bool b;
            integer i;
            uinteger u;
            rational r;
            complex c;
            real f;
        };
    };

    namespace ast {
        /**
         * Node kind
         */
        enum class kind {
            null_statement,
            expression_statement,
            assignment_statement,
            later_statement,
            return_statement,
            break_statement,
            continue_statement,
            contract_statement,
            field_declaration,
            tuple_field_declaration,
            parameter_declaration,
            var_declaration,
            var_tupled_declaration,
            const_declaration,
            const_tupled_declaration,
            generic_clause_declaration,
            generic_const_parameter_declaration,
            generic_type_parameter_declaration,
            test_declaration,
            function_declaration,
            property_declaration,
            concept_declaration,
            extend_declaration,
            behaviour_declaration,
            extern_declaration,
            range_declaration,
            record_declaration,
            variant_declaration,
            alias_declaration,
            use_declaration,
            workspace_declaration,
            source_unit_declaration,
            bit_field_type_expression,
            path_type_expression,
            array_type_expression,
            tuple_type_expression,
            record_type_expression,
            function_type_expression,
            pointer_type_expression,
            variant_type_expression,
            literal_expression,
            identifier_expression,
            tuple_expression,
            array_expression,
            array_sized_expression,
            parenthesis_expression,
            block_expression,
            function_expression,
            postfix_expression,
            call_expression,
            member_expression,
            array_index_expression,
            tuple_index_expression,
            record_expression,
            unary_expression,
            binary_expression,
            implicit_conversion_expression,
            range_expression,
            path_pattern_expression,
            ignore_pattern_expression,
            literal_pattern_expression,
            tuple_pattern_expression,
            array_pattern_expression,
            record_pattern_expression,
            labeled_record_pattern_expression,
            range_pattern_expression,
            or_pattern_expression,
            cast_pattern_expression,
            when_expression,
            when_cast_expression,
            when_pattern_expression,
            for_loop_expression,
            for_range_expression,
            if_expression,
            workspace
        };
        /**
         * Fundamental class which represents a node inside the
         * abstract syntax tree. Expressions, declarations and
         * statements all extends this class.
         */
        class node {
        protected:
            /**
             * Default constructor
             */
            node() : range_(), invalid_(0) {}
            /**
             * Construct a new node object
             * @param range Range of node inside source code [begin, end)
             */
            node(source_range range);
            /**
             * Range of node inside source code
             */
            mutable source_range range_;
            /**
             * This bit is set when the node is malformed
             * or contains errors
             */
            mutable unsigned int invalid_ : 1;
        public:
            /**
             * @return Node kind
             */
            virtual ast::kind kind() const = 0;
            /**
             * @return true if invalid bit is set 
             */
            bool invalid() const;
            /**
             * Sets the invalid
             * @param err invalid flag
             */
            void invalid(bool err) const;
            /**
             * @return Range of node inside source text [begin, end)
             */
            source_range& range() const;
            /**
             * Destroys the node object
             */
            virtual ~node();
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            virtual void accept(visitor& visitor) const = 0;
        };

        class function_declaration;

        /**
         * The root class for expressions inside the AST
         */
        class expression : public node {
        public:
            /**
             * Annotation for expressions so their inferred type can be stored
             */
            struct annotation {
                /**
                 * Type annotation
                 */
                ast::pointer<ast::type> type = nullptr;
                /**
                 * Value computed at compile time, if any
                 */
                constval value;
                /**
                 * This flag tells if the expression must be resolved
                 * exclusively as a value (variable, constant or temporary)
                 */
                bool mustvalue : 1;
                /**
                 * This flag tells if the expression must be resolved
                 * exclusively as a type
                 */
                bool musttype : 1;
                /**
                 * This flag tells if the expression is a type name
                 * or if is a variable/constant name
                 */
                bool istype : 1;
                /**
                 * This flag tells if the expression is a concept name
                 */
                bool isconcept : 1;
                /**
                 * This flag tells if the expression is a function name
                 * or if is a variable/constant name
                 */
                bool iscallable : 1;
                /**
                 * This flag tells if the expression is parametric which means
                 * it is a parametric type or constant
                 */
                bool isparametric : 1;
                /**
                 * This flag tells if variable name could be resolved as a binding name
                 */
                bool ispattern : 1;
                /**
                 * This flags tells if an identifier expression representing a parametric
                 * function must be deduced all from its generic arguments and not inferred
                 * from arguments of function call.
                 * It is true by default, but it is set to false when we have a function call
                 * that let us deduce generics from arguments
                 */
                bool deduce : 1;
                /**
                 * When the expression is an identifier, it may reference directly a variable,
                 * constant, function or type
                 */
                const ast::declaration* referencing = nullptr;
                /**
                 * When the declaration is associated to a scope
                 */
                const environment* associated = nullptr;
                /**
                 * Substitution of generic parameters
                 */
                ast::pointer<struct substitution> substitution = nullptr;
                /**
                 * When the expression is translated to some implicit function
                 */
                const ast::function_declaration* implicit_procedure = nullptr;
                /**
                 * Constructs an empty annotation
                 */
                annotation() : value(), mustvalue(true), musttype(false), istype(false), isconcept(false), iscallable(false), isparametric(false), ispattern(false), deduce(true) {}
            };
        protected:
            /**
             * Construct a new expression object
             * @param range The range which contains an expression
             */
            expression(source_range range);
            /**
             * annotation
             */
            mutable annotation annotation_;
        public:
            /**
             * Clone an expression
             */
            virtual pointer<expression> clone() const { return nullptr; }
            /**
             * @return Annotation
             */
            expression::annotation& annotation() const { return annotation_; }
            /**
             * This is useful when a field expression looks like a path.
             * For example `a.b.c` is either a field expression but it
             * could be a path.
             * 
             * @return true If expression looks like a path
             * @return false If expression couldn't be a path
             */
            virtual bool is_path() const = 0;
            /**
             * This tests if the expression could be the left hand of
             * an assignment.
             * 
             * @return true If the expression could stay on the left side of assignment
             * @return false Otherwise
             */
            virtual bool is_assignable() const = 0;
            /**
             * Returns the immutable variable which it references, if any
             * 
             * @return Immutable variabile it references, if any
             */
            virtual const ast::declaration* immutable() const { return nullptr; }
            /**
             * Returns the referencing variable it references, if any
             * 
             * @return Referencing variable, if any
             */
            virtual const ast::declaration* lvalue() const { return nullptr; }
            /**
             * Destroys the expression object
             */
            virtual ~expression();
        };
        /**
         * The root class for statements inside the AST
         * @note Any statement could contain the ending semicolon `;` if written
         */
        class statement : public node {
        public:
            /**
             * Annotation for statement, but it is intended more precisely for declarations
             */
            struct annotation {
                /**
                 * Type annotation
                 */
                ast::pointer<ast::type> type = nullptr;
                /**
                 * Enclosing scope
                 */
                const ast::node* scope = nullptr;
                /**
                 * Extension block
                 */
                const ast::declaration* extendblock = nullptr;
                /**
                 * Visited symbol for analysis
                 */
                bool visited : 1;
                /**
                 * Resolved symbol for analysis
                 */
                bool resolved : 1;
                /**
                 * Use count, which is the number a declaration name is referenced
                 */
                unsigned long usecount = 0;
                /**
                 * Constructor
                 */
                annotation() : visited(false), resolved(false) {}
            };
            /**
             * Destroys the statement object
             */
            virtual ~statement();
            /**
             * Clone a statement
             */
            virtual pointer<statement> sclone() const { return nullptr; }
            /**
             * @return Annotation
             */
            statement::annotation& annotation() const { return annotation_; }
        protected:
            /**
             * Construct a new statement object
             * @param range Range in source code
             */
            statement(source_range range);
            /**
             * Annotation
             */
            mutable struct annotation annotation_;
        };
        /**
         * Empty statements, for example `,`
         */
        class null_statement : public statement {
        public:
            /**
             * Constructs a new null statement object
             * @param range Range in source code
             */
            null_statement(source_range range);
            /**
             * Destroys the null statement object
             */
            ~null_statement();
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a statement
             */
            pointer<statement> sclone() const { return create<null_statement>(range_); }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::null_statement; } 
        };
        /**
         * Represents expression statement, which is a
         * statement holding an expression (if expression,
         * call expression, ecc)
         */
        class expression_statement : public statement {
        public:
            /**
             * Constructs a new expression statement object
             * @param range Range in source code
             */
            expression_statement(source_range range, pointer<ast::expression> expr);
            /**
             * Destroys the statement object
             */
            ~expression_statement();
            /**
             * @return Reference to the underlying expression
             */
            pointer<ast::expression>& expression() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a statement
             */
            pointer<statement> sclone() const { return create<expression_statement>(range_, expr_->clone()); }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::expression_statement; } 
        private:
            /**
             * Underlying expression
             */
            mutable pointer<ast::expression> expr_;
        };
        /**
         * Represents an assignment expression, so the left side
         * must be assignable. For example
         * `a = f()`, `a.b += c`, `reference() = value`, ecc
         */
        class assignment_statement : public statement {
        public:
            /**
             * Construct a new assignment statement object
             * @param range Range in source code
             * @param op Assignment operator (`=`, `+=`, `-=`, `**=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `>>=`, `<<=`)
             * @param left Left expression, necessarily assignable
             * @param right Right expression, assigned value
             */
            assignment_statement(source_range range, token op, pointer<ast::expression> left, pointer<ast::expression> right);
            /**
             * Destroy the statement object
             */
            ~assignment_statement();
            /**
             * @return Assignment operator  (`=`, `+=`, `-=`, `**=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `>>=`, `<<=`)
             */
            token& assignment_operator() const;
            /**
             * @return Reference to the left expression
             */
            pointer<ast::expression>& left() const;
            /**
             * @return Reference to the right expression
             */
            pointer<ast::expression>& right() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a statement
             */
            pointer<statement> sclone() const { return create<assignment_statement>(range_, op_, left_->clone(), right_->clone()); }

            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::assignment_statement; } 
        private:
            /**
             * Assignment operator
             */
            mutable token op_;
            /**
             * Left expression, must be assignable
             */
            mutable pointer<ast::expression> left_;
            /**
             * Right expression
             */
            mutable pointer<ast::expression> right_;
        };
        /**
         * Later statement, used to execute code on exit from block
         */
        class later_statement : public statement {
        public:
            /**
             * Construct a new return statement object
             * @param range Range in source code
             * @param expr Expression for code
             */
            later_statement(source_range range, pointer<ast::expression> expr);
            /**
             * Destroys the statement object
             */
            ~later_statement();
            /**
             * @return Reference to the expression, if any
             */
            pointer<ast::expression>& expression() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a statement
             */
            pointer<statement> sclone() const { return create<later_statement>(range_, expr_ ? expr_->clone() : nullptr); }

            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::later_statement; } 
        private:
            /**
             * Returned value, could be null
             */
            mutable pointer<ast::expression> expr_;
        };
        /**
         * Simple return statement, for example
         * `return;` when there is no return value
         * `return value`when there is a return value
         * It must be inside a function body
         */
        class return_statement : public statement {
        public:
            /**
             * Construct a new return statement object
             * @param range Range in source code
             * @param expr Returned value, could be null
             */
            return_statement(source_range range, pointer<ast::expression> expr);
            /**
             * Destroys the statement object
             */
            ~return_statement();
            /**
             * @return Reference to the returned expression, if any
             */
            pointer<ast::expression>& expression() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a statement
             */
            pointer<statement> sclone() const { return create<return_statement>(range_, expr_ ? expr_->clone() : nullptr); }

            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::return_statement; } 
        private:
            /**
             * Returned value, could be null
             */
            mutable pointer<ast::expression> expr_;
        };
        /**
         * Simple break statement, for example
         * `break;` when there is no return value
         * `break value`when there is a return value
         * It must be inside a for (loop or range) body
         */
        class break_statement : public statement {
        public:
            /**
             * Construct a new break statement object
             * @param range Range in source code
             * @param expr Returned value, could be null
             */
            break_statement(source_range range, pointer<ast::expression> expr);
            /**
             * Destroys the statement object
             */
            ~break_statement();
            /**
             * @return Reference to the returned expression, if any
             */
            pointer<ast::expression>& expression() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a statement
             */
            pointer<statement> sclone() const { return create<break_statement>(range_, expr_ ? expr_->clone() : nullptr); }

            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::break_statement; } 
        private:
            /**
             * Returned value, could be null
             */
            mutable pointer<ast::expression> expr_;
        };
        /**
         * Simple continue statement, for example
         * It must be inside a for (loop or range) body
         */
        class continue_statement : public statement {
        public:
            continue_statement(source_range range);
            /**
             * Destroys the statement object
             */
            ~continue_statement();
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a statement
             */
            pointer<statement> sclone() const { return create<continue_statement>(range_); }

            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::continue_statement; } 
        };
        /**
         * Contract statement, for example
         * `require i >= 0`
         * or
         * `invariant sorted(array)`
         */
        class contract_statement : public statement {
        public:
            /**
             * Constructs a new contract statement object
             * @param range Range in source text
             * @param specifier Contract specifier (`require`, `ensure` or `invariant`)
             * @param expr Tested expression
             */
            contract_statement(source_range range, token specifier, pointer<ast::expression> expr);
            /**
             * Destroys the statement object
             */
            ~contract_statement();
            /**
             * @return Contract specifier
             */
            token& specifier() const;
            /**
             * @return Tested condition
             */
            pointer<ast::expression>& condition() const;
            /**
             * @return true If specifier is `require`
             * @return false Otherwise
             */
            bool is_require() const;
            /**
             * @return true If specifier is `ensure`
             * @return false Otherwise
             */
            bool is_ensure() const;
            /**
             * @return true If specifier is `invariant`
             * @return false Otherwise
             */
            bool is_invariant() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a statement
             */
            pointer<statement> sclone() const { return create<contract_statement>(range_, specifier_, condition_->clone()); }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::contract_statement; } 
        private:
            /**
             * Contract specifier
             */
            mutable token specifier_;
            /**
             * Expression
             */
            mutable pointer<ast::expression> condition_;
        };

        class extend_declaration;

        /**
         * Root class for declarations inside the AST
         */
        class declaration : public statement {
        public:
            /**
             * Destroys the declaration object
             */
            virtual ~declaration();
            /**
             * Sets hidden bit
             * @param flag Hidden flag
             */
            void hidden(bool flag);
            /**
             * Tells if declaration is hidden, which
             * means that is has `hide` keyword before.
             * This prevents the declaration to be visibile
             * outside its workspace
             * @return true If declaration is not visible outside the workspace
             * @return false Othwerwise
             */
            bool is_hidden() const;
            /**
             * Clone a declaration
             */
            virtual pointer<declaration> clone() const = 0;
            /**
             * Set/get extension block
             */
            const ast::extend_declaration*& extension() const { return extension_; }
        protected:
            /**
             * @param range Range in source code
             */
            declaration(source_range range);
        private:
            /**
             * Hidden flag
             */
            bool hidden_;
            /**
             * Extension block, if any
             */
            mutable const ast::extend_declaration* extension_ = nullptr;
        };
        /**
         * Clone a list of expressions
         */
        pointers<expression> clone(const pointers<expression>& source);
        /**
         * Clone a list of statements
         */
        pointers<statement> clone(const pointers<statement>& source);
        /**
         * Clone a list of declarations
         */
        pointers<declaration> clone(const pointers<declaration>& source);
        /**
         * A type declaration can be one of the followings:
         *  - record (struct or union) type declaration
         *  - variant type declaration
         *  - range type declaration
         *  - alias name declaration
         */
        class type_declaration : public declaration {
        public:
            /**
             * Constructs a new type declaration object
             * @param range Range in source text
             * @param name Type name
             * @param generic Generic clause
             */
            type_declaration(source_range range, token name, pointer<ast::declaration> generic);
            /**
             * Destroys the declaration object
             */
            virtual ~type_declaration();
            /**
             *  @return Range name
             */
            token& name() const;
            /**
             * @return Generic clause
             */
            pointer<ast::declaration> generic() const;
            /**
             * @return Set generic clause
             */
            void generic(pointer<ast::declaration> clause);
        private:
            /**
             * Type name 
             */
            mutable token name_;
            /**
             * Generic clause
             */
            pointer<ast::declaration> generic_;
        }; 
        /**
         * A field declaration appears inside a record declaration, for example a
         * data or union declaration. For example `data Person(name: &chars, age: natural)`.
         * It is a kind of name declaration.
         */
        class field_declaration : public declaration {
        public:
            /**
             * Constructs a new field declaration object
             * @param range Range in source code
             * @param name Name of field
             * @param ty_expr Type annotation
             */
            field_declaration(source_range range, token name, pointer<ast::expression> ty_expr);
            /**
             * Destroys the declaration object
             */
            virtual ~field_declaration();
            /**
             * @return Name of field
             */
            token& name() const;
            /**
             * @return Type annotation
             */
            pointer<ast::expression>& type_expression() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a declaration
             */
            pointer<declaration> clone() const 
            { 
                auto result = create<field_declaration>(range_, name_, type_expr_->clone());
                result->annotation_ = annotation_;
                result->hidden(is_hidden());
                return result;
            }
            pointer<statement> sclone() const { return clone(); }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::field_declaration; } 
        private:
            /**
             * Name of declared variable 
             */
            mutable token name_;
            /**
             * Its type annotation
             */
            mutable pointer<ast::expression> type_expr_;
        };

        /**
         * It is a field inside a record which is not referenced by its name but by index.
         * For example, in `data User(String, age)` fields haven't got any names, but they
         * are accessible as `.0` and `.1`
         */
        class tuple_field_declaration : public declaration {
        public:
            /**
             * Constructs a new field declaration object
             * @param range Range in source code
             * @param index Index of field
             * @param ty_expr Type annotation
             */
            tuple_field_declaration(source_range range, unsigned index, pointer<ast::expression> ty_expr);
            /**
             * Destroys the declaration object
             */
            virtual ~tuple_field_declaration();
            /**
             * @return Index of field 
             */
            unsigned index() const;
            /**
             * @return Type annotation
             */
            pointer<ast::expression>& type_expression() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a declaration
             */
            pointer<declaration> clone() const 
            { 
                auto result = create<tuple_field_declaration>(range_, index_, type_expr_->clone());
                result->annotation_ = annotation_;
                result->hidden(is_hidden());
                return result;
            }
            pointer<statement> sclone() const { return clone(); }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::tuple_field_declaration; } 
        private:
            /**
             * Index of field, which substitutes name of field
             */
            unsigned index_;
            /**
             * Type annotation
             */
            mutable pointer<ast::expression> type_expr_;
        };
        /**
         * Simple var declaration, for example
         * `static val names: [String] = ["Cain"s, "Abel"s, "Azazel"s]
         * which has type [String: 3] and is static
         * Variables must always be initialized
         */
        class var_declaration : public declaration {
        public:
            /**
             * Construct a new var declaration object
             * @param range Range in source code
             * @param specifiers Lifetime specifiers, which must be one
             * @param name Variable name
             * @param ty_expr Type annotation
             * @param value Initial value
             */
            var_declaration(source_range range, std::vector<token> specifiers, token name, pointer<ast::expression> ty_expr, pointer<ast::expression> value);
            /**
             * Destroys the declaration object
             */
            ~var_declaration();
            /**
             * Tells if variable is mutable, which means that its value
             * can be changed through the variable itself or it can be
             * reassigned eventually
             * @return true If variable is declared as mutable
             * @return false Otherwise
             */
            bool is_mutable() const;
            /**
             * A variable has automatic lifetime when it is created when
             * the holding function stack frame is allocated and it is destroyed when
             * the same function stack frame is deallocated. This is the default configuration
             * @return true If the variable is declared without any specifiers
             * @return false Otherwise
             */
            bool is_automatic() const;
            /**
             * A variable has static lifetime when it is destroyed as the process (program)
             * terminates.
             * @return true If the variable is declared with `static` specifier
             * @return false Otherwise
             */
            bool is_static() const;
            /**
             * Sets var as mutable
             */
            void set_mutable(bool flag) { mutable_ = flag; }
            /**
             * Sets var as automatic
             */
            void set_automatic(bool flag) { automatic_ = flag; }
            /**
             * Sets var as static
             */
            void set_static(bool flag) { static_ = flag; }
            /**
             * @return Variable name
             */
            token& name() const;
            /**
             * @return Type annotation
             */
            pointer<ast::expression>& type_expression() const;
            /**
             * @return Variable initial value
             */
            pointer<ast::expression>& value() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a declaration
             */
            pointer<declaration> clone() const 
            { 
                auto copy = create<var_declaration>(range_, std::vector<token>(), name_, type_expr_ ? type_expr_->clone() : nullptr, value_ ? value_->clone() : nullptr);
                copy->mutable_ = mutable_;
                copy->automatic_ = automatic_;
                copy->static_ = static_;
                copy->annotation_ = annotation_;
                return copy; 
            }
            pointer<statement> sclone() const { return clone(); }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::var_declaration; } 
        protected:
            /**
             * Constant name
             */
            mutable token name_;
            /**
             * Type annotation
             */
            mutable pointer<ast::expression> type_expr_;
            /**
             * Initial value
             */
            mutable pointer<ast::expression> value_;
            /**
             * Mutability bit
             */
            bool mutable_: 1;
            /**
             * Automatic bit
             */
            bool automatic_: 1;
            /**
             * Static bit
             */
            bool static_: 1;
        };
        /**
         * Parameter declaration inside function or method parameter list. For example
         * `function logarithm(base: real, arg: real) {...}` has parameters `base` and `arg`
         */
        class parameter_declaration : public var_declaration {
        public:
            /**
             * Construct a new parameter declaration object
             * @param range Range in source code
             * @param name Parameter name
             * @param ty_expr Type annotation
             * @param is_mutable Parameter mutability
             * @param is_variadic If this paramater is intrepreted as a list of variable arity
             */
            parameter_declaration(source_range range, token name, pointer<ast::expression> ty_expr, bool is_mutable = false, bool is_variadic = false);
            /**
             * Destroys the declaration object
             */
            ~parameter_declaration();
            /**
             * A parameter is variadic if declared as `function sum(...numbers: i32) {}`
             * @return true If parameter is mutable
             * @return false Otherwise
             */
            bool is_variadic() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a declaration
             */
            pointer<declaration> clone() const 
            { 
                auto result = create<parameter_declaration>(range_, name_, type_expr_->clone(), mutable_, variadic_);
                result->annotation_ = annotation_;
                result->hidden(is_hidden());
                return result;
            }
            pointer<statement> sclone() const { return clone(); }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::parameter_declaration; } 
        private:
            /**
             * Parameter is variadic
             */
            bool variadic_ : 1;
        };
        /**
         * A var tuple declaration is used for destructuring. For example
         * `val (name, age): (String, int) = Person(name: "Azrael"s, age: 35)`
         */
        class var_tupled_declaration : public declaration {
        public:
            /**
             * Construct a new var tupled declaration object
             * @param range Range in source code
             * @param specifiers Lifetime specifiers, which must be one
             * @param names Variables' names
             * @param ty_expr Type annotation
             * @param value Initial value
             */
            var_tupled_declaration(source_range range, std::vector<token> specifiers, std::vector<token> names, pointer<ast::expression> ty_expr, pointer<ast::expression> value);
            /**
             * Destroys the declaration object
             */
            ~var_tupled_declaration();
            /**
             * Tells if variable is mutable, which means that its value
             * can be changed through the variable itself or it can be
             * reassigned eventually
             * @return true If variable is declared as mutable
             * @return false Otherwise
             */
            bool is_mutable() const;
            /**
             * A variable has automatic lifetime when it is created when
             * the holding function stack frame is allocated and it is destroyed when
             * the same function stack frame is deallocated. This is the default configuration
             * @return true If the variable is declared without any specifiers
             * @return false Otherwise
             */
            bool is_automatic() const;
            /**
             * A variable has static lifetime when it is destroyed as the process (program)
             * terminates.
             * @return true If the variable is declared with `static` specifier
             * @return false Otherwise
             */
            bool is_static() const;
            /**
             * @return Variable initial value
             */
            pointer<ast::expression>& value() const;
            /**
             * @return Variables' names
             */
            std::vector<token>& names() const;
            /**
             * @return Type annotation, which must be a tuple_type_expression
             */
            pointer<ast::expression>& type_expression() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a declaration
             */
            pointer<declaration> clone() const 
            { 
                auto copy = create<var_tupled_declaration>(range_, std::vector<token>(), names_, type_expression_ ? type_expression_->clone() : nullptr, value_->clone());
                copy->mutable_ = mutable_;
                copy->automatic_ = automatic_;
                copy->static_ = static_;
                copy->annotation_ = annotation_;
                return copy; 
            }
            pointer<statement> sclone() const { return clone(); }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::var_tupled_declaration; } 
        private:
            /**
             * Variables' names
             */
            mutable std::vector<token> names_;
            /**
             * Type annotation
             */
            mutable pointer<ast::expression> type_expression_;
            /**
             * Initial value
             */
            mutable pointer<ast::expression> value_;
            /**
             * Mutability bit
             */
            bool mutable_: 1;
            /**
             * Automatic bit
             */
            bool automatic_: 1;
            /**
             * Static bit
             */
            bool static_: 1;
        };
        /**
         * A constant contains a compile-time expression, for example
         * `const PI = 3.14159r`
         */
        class const_declaration : public declaration {
        public:
            /**
             * Construct a new const declaration object
             * @param range Range in source code
             * @param name Variable name
             * @param ty_expr Type annotation
             * @param value Initial value
             */
            const_declaration(source_range range, token name, pointer<ast::expression> ty_expr, pointer<ast::expression> value);
            /**
             * Destroys the declaration object
             */
            ~const_declaration();
            /**
             * @return Constant name
             */
            token& name() const;
            /**
             * @return Type annotation
             */
            pointer<ast::expression>& type_expression() const;
            /**
             * Initial value which must be a compile-time expression
             * @return Initial value
             */
            pointer<ast::expression>& value() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a declaration
             */
            pointer<declaration> clone() const 
            { 
                auto result = create<const_declaration>(range_, name_, type_expr_ ? type_expr_->clone() : nullptr, value_->clone());
                result->annotation_ = annotation_;
                result->hidden(is_hidden());
                return result;
            }
            pointer<statement> sclone() const { return clone(); }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::const_declaration; } 
        private:
            /**
             * Constant name
             */
            mutable token name_;
            /**
             * Type annotation
             */
            mutable pointer<ast::expression> type_expr_;
            /**
             * Inital value
             */
            mutable pointer<ast::expression> value_;
        };
        /**
         * Group of constants, for example `const (PI, E) = (3.14159, 2.718)
         */
        class const_tupled_declaration : public declaration {
        public:
            /**
             * Construct a new const tupled declaration object
             * @param range Range in source code
             * @param names Variables' names
             * @param ty_expr Type annotation
             * @param value Initial value
             */
            const_tupled_declaration(source_range range, std::vector<token> names, pointer<ast::expression> ty_expr, pointer<ast::expression> value);
            /**
             * Destroys the declaration object
             */
            ~const_tupled_declaration();
            /**
             * @return Constants names
             */
            std::vector<token>& names() const;
            /**
             * @return Type annotation
             */
            pointer<ast::expression>& type_expression() const;
            /**
             * @return Initial value, which must be a compile-time expression
             */
            pointer<ast::expression>& value() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a declaration
             */
            pointer<declaration> clone() const 
            {
                auto result = create<const_tupled_declaration>(range_, names_, type_expression_ ? type_expression_->clone() : nullptr, value_->clone());
                result->annotation_ = annotation_;
                result->hidden(is_hidden());
                return result;
            }
            pointer<statement> sclone() const { return clone(); }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::const_tupled_declaration; } 
        private:
            /**
             * Constants names
             */
            mutable std::vector<token> names_;
            /**
             * Type annotation
             */
            mutable pointer<ast::expression> type_expression_;
            /**
             * Initial value 
             */
            mutable pointer<ast::expression> value_;
        };
        /**
         * A generic clause is composed by two parts:
         *  - a generic parameters list: types or constants, for example
         * `(T, U, SIZE: usize)
         *  - constraints, which are expressed through concepts on types and/or constants, like
         * `if Addition(T, U) & (Compare(T) | Compare(U))
         */
        class generic_clause_declaration : public declaration {
        public:
            /**
             * Construct a new generic clause declaration object
             * @param range Range in source text
             * @param parameters Generic parameters list
             * @param constraint Constraint expression
             */
            generic_clause_declaration(source_range range, ast::pointers<ast::declaration> parameters, ast::pointer<expression> constraint);
            /**
             * Destroy the declaration object
             */
            ~generic_clause_declaration();
            /**
             * @return Generic parameters list
             */
            ast::pointers<ast::declaration>& parameters() const;
            /**
             * @return Constraint expression over parameters
             */
            ast::pointer<ast::expression>& constraint() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a declaration
             */
            pointer<declaration> clone() const 
            { 
                auto result = create<generic_clause_declaration>(range_, ast::clone(parameters_), constraint_ ? constraint_->clone() : nullptr);
                result->annotation_ = annotation_;
                result->hidden(is_hidden());
                return result;
            }
            pointer<statement> sclone() const { return clone(); }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::generic_clause_declaration; } 
        private:
            /**
             * Generic clause
             */
            mutable pointers<ast::declaration> parameters_;
            /**
             * Constraint expression over parameters
             */
            mutable ast::pointer<ast::expression> constraint_;
        };
        /**
         * Represents a constant declaration as a generic parameter, for example
         * `type(T, N: int) if Default(T) Array(hide data: [T: N])` 
         * where N is must be a compile time expression
         */
        class generic_const_parameter_declaration : public declaration {
        public:
            /**
             * Construct a new var declaration object
             * @param range Range in source code
             * @param name Variable name
             * @param ty_expr Type annotation
             */
            generic_const_parameter_declaration(source_range range, token name, pointer<ast::expression> type_expr);
            /**
             * Destroys the declaration object 
             */
            ~generic_const_parameter_declaration();
            /**
             * @return Constant name
             */
            token& name() const;
            /**
             * @return Type annotation
             */
            pointer<ast::expression>& type_expression() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a declaration
             */
            pointer<declaration> clone() const 
            { 
                auto result = create<generic_const_parameter_declaration>(range_, name_, type_expr_->clone());
                result->annotation_ = annotation_;
                result->hidden(is_hidden());
                return result;
            }
            pointer<statement> sclone() const { return clone(); }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::generic_const_parameter_declaration; } 
        private:
            /**
             * Constant name
             */
            mutable token name_;
            /**
             * Type annotation
             */
            mutable pointer<ast::expression> type_expr_;
        };
        /**
         * Represents a type declaration as a generic parameter, for example
         * `type(T, N: int) if Default(T) Array(hide data: [T: N])` 
         * where T is a type that must satisfy the Default concept constraint
         */
        class generic_type_parameter_declaration : public type_declaration {
        public:
            /**
             * Constructs a new generic type parameter declaration object
             * @param range Range in source code
             * @param name Generic type name
             */
            generic_type_parameter_declaration(source_range range, token name);
            /**
             * Destroys the declaration object
             */
            ~generic_type_parameter_declaration();
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a declaration
             */
            pointer<declaration> clone() const 
            { 
                auto result = create<generic_type_parameter_declaration>(range_, name()); 
                result->annotation_ = annotation_;
                result->hidden(is_hidden());
                return result;
            }
            pointer<statement> sclone() const { return clone(); }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::generic_type_parameter_declaration; } 
        };
        /**
         * A test declaration is a block of executing code
         * for unit testing, for example
         * `test test_this_unit {...}`
         */
        class test_declaration : public ast::declaration {
        public:
            /**
             * Constructs a new test declaration object
             * @param range Range in source code
             * @param name Name of test
             * @param body Body of test, which is a block like `{...}`
             */
            test_declaration(source_range range, token name, pointer<ast::expression> body);
            /**
             * Destroys the declaration object
             */
            ~test_declaration();
            /**
             * @return Test name
             */
            token& name() const;
            /**
             * @return Test body
             */
            pointer<ast::expression>& body() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a declaration
             */
            pointer<declaration> clone() const 
            { 
                auto result = create<test_declaration>(range_, name_, body_->clone());
                result->annotation_ = annotation_;
                result->hidden(is_hidden());
                return result;
            }
            pointer<statement> sclone() const { return clone(); }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::test_declaration; } 
        private:
            /**
             * Test name 
             */
            mutable token name_;
            /**
             * Test body
             */
            mutable pointer<ast::expression> body_;
        };
        /**
         * Simple function declaration. For example
         * `function(T) if Compare(T) sort(mutable sequence: [T]) { ... }`
         * or
         * `function(T) if Compare(T) binary_search(sequence: [T])
         *      require sorted(sequence)
         * { ... }`
         */
        class function_declaration : public declaration {
        public:
            /**
             * Constructs a new function declaration object
             * @param range Range in source code
             * @param name Function name
             * @param generic Generic clause
             * @param params Parameters list
             * @param return_type_expr Return type annotation
             * @param body Function body, if any
             * @param contracts Contract clause composed of contract statements
             */
            function_declaration(source_range range, token name, pointer<ast::declaration> generic, pointers<ast::declaration> params, pointer<ast::expression> return_type_expr, pointer<ast::expression> body, pointers<ast::statement> contracts);
            /**
             * Destroys the declaration object
             */
            virtual ~function_declaration();
            /**
             * @return Function name
             */
            token& name() const;
            /**
             * @return Generic clause
             */
            pointer<ast::declaration>& generic() const;
            /**
             * @return Parameters list
             */
            pointers<ast::declaration>& parameters() const;
            /**
             * @return Return type annotation
             */
            pointer<ast::expression>& return_type_expression() const;
            /**
             * @return Function body, if any (for example functions declared
             * inside extern blocks cannot have a body)
             */
            pointer<ast::expression>& body() const;
            /**
             * @return List of contract statements
             */
            pointers<ast::statement>& contracts() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a declaration
             */
            pointer<declaration> clone() const 
            { 
                auto result = create<function_declaration>(range_, name_, generic_ ? generic_->clone() : nullptr, ast::clone(params_), return_type_expr_ ? return_type_expr_->clone() : nullptr, body_ ? body_->clone() : nullptr, ast::clone(contracts_)); 
                result->annotation_ = annotation_;
                result->hidden(is_hidden());
                return result;
            }
            pointer<statement> sclone() const { return clone(); }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::function_declaration; }
            /**
             * Source range of result type, if any
             */
            source_range& result_range() const { return result_range_; }
            /**
             * It tells if function has extern linkage
             */
            bool external : 1;
        protected:
            /**
             * Function name
             */
            mutable token name_;
            /**
             * Generic clause
             */
            mutable pointer<ast::declaration> generic_;
            /**
             * Parameters list
             */
            mutable pointers<ast::declaration> params_;
            /**
             * Return type annotation
             */
            mutable pointer<ast::expression> return_type_expr_;
            /**
             * Function body 
             */
            mutable pointer<ast::expression> body_;
            /**
             * Contract clauses
             */
            mutable pointers<ast::statement> contracts_;
            /**
             * Source range for return type
             */
            mutable source_range result_range_;
        };
        /**
         * A property is like a function which acts on an object. We can think of it
         * as a getter function. It can't be generic and it must take as its argument
         * an object whose type matches the one of the extend block. For example
         * `extend(T : Numeric, N, M) matrix(T, N, M) {
         *     // this property computes the matrix determinant 
         *     .determinant(m: matrix(T, N, M)) T = ...
         *     // this property computes the matrix rank
         *     .rank(m: matrix(T, N, M)) T = ...
         * }`
         */
        class property_declaration : public declaration {
        public:
            /**
             * Constructs a new property declaration object
             * @param range Range in source code
             * @param name Property name
             * @param params Parameters list
             * @param return_type_expr Return type annotation
             * @param body Property body, if any
             */
            property_declaration(source_range range, token name, pointers<ast::declaration> params, pointer<ast::expression> return_type_expr, pointer<ast::expression> body, pointers<ast::statement> contracts);
            /**
             * Destroys the declaration object
             */
            virtual ~property_declaration();
            /**
             * @return Property name
             */
            token& name() const;
            /**
             * @return Parameters list
             */
            pointers<ast::declaration>& parameters() const;
            /**
             * @return Return type annotation
             */
            pointer<ast::expression>& return_type_expression() const;
            /**
             * @return Property body, if any (for example abstract properties inside
             * behaviour blocks haven't any body)
             */
            pointer<ast::expression>& body() const;
            /**
             * @return List of contract statements
             */
            pointers<ast::statement>& contracts() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a declaration
             */
            pointer<declaration> clone() const 
            { 
                auto result = create<property_declaration>(range_, name_, ast::clone(params_), return_type_expr_ ? return_type_expr_->clone() : nullptr, body_ ? body_->clone() : nullptr, ast::clone(contracts_)); 
                result->annotation_ = annotation_;
                result->hidden(is_hidden());
                return result;
            }
            pointer<statement> sclone() const { return clone(); }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::property_declaration; } 
        private:
            /**
             * Property name
             */
            mutable token name_;
            /**
             * Parameters list
             */
            mutable pointers<ast::declaration> params_;
            /**
             * Return type annotation
             */
            mutable pointer<ast::expression> return_type_expr_;
            /**
             * Property body 
             */
            mutable pointer<ast::expression> body_;
            /**
             * Contract clauses
             */
            mutable pointers<ast::statement> contracts_;
        };
        /**
         * A concept declaration defines some restrictions over a type specified
         * through functions and properties. For example we have
         * `concept(T) Compare as Base1(T) | Base2(T) {
         *     less(left: T, right: T) bool
         *     less_equal(left: T, right: T) bool
         *     gretater(left: T, right: T) bool
         *     greater_equal(left: T, right: T) bool
         * }`
         */
        class concept_declaration : public declaration {
        public:
            /**
             * Construct a new concept declaration object
             * @param range Range in source text
             * @param generic Generic clause
             * @param name Concept name
             * @param base Base concept expression, if any, which is inherithed
             * @param declarations List of prototypes
             */
            concept_declaration(source_range range, pointer<ast::declaration> generic, token name, pointer<ast::expression> base, pointers<ast::declaration> prototypes);
            /**
             * Destroys the declaration object
             */
            ~concept_declaration();
            /**
             * @return Generic clause
             */
            pointer<ast::declaration>& generic() const;
            /**
             * @return Concept name
             */
            token& name() const;
            /**
             * @return Base concept expression
             */
            pointer<ast::expression>& base() const;
            /**
             * @return List of prototypes
             */
            pointers<ast::declaration>& prototypes() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a declaration
             */
            pointer<declaration> clone() const 
            { 
                auto result = create<concept_declaration>(range_, generic_ ? generic_->clone() : nullptr, name_, base_ ? base_->clone() : nullptr, ast::clone(prototypes_)); 
                result->annotation_ = annotation_;
                result->hidden(is_hidden());
                return result;
            }
            pointer<statement> sclone() const { return clone(); }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::concept_declaration; } 
        private:
            /**
             * Generic clause
             */
            mutable pointer<ast::declaration> generic_;
            /**
             * Concept name
             */
            mutable token name_;
            /**
             * Concept base expression
             */
            mutable pointer<ast::expression> base_;
            /**
             * List of prototypes
             */
            mutable pointers<ast::declaration> prototypes_;
        };
        /**
         * An extension block adds functions, properties or constants to the data type
         * `// extend Array(T, N) as a default constructible object
         * extend(T, N: int) if Default(T) & Clone(T) Array(T, N) {
         *     // creator function
         *     default() Array(T, N) => Array!(T, N)(data: [T.default(): N])
         *     // function which mimics a method
         *     first(a: Array(T, N)) T = a.data[0]
         *     // properties
         *     .size(a: Array(T, N)) int = N
         *     // constant
         *     const length = N
         * }
         * // when we want to extend a polymorphic type then it must extends a shared behaviour
         * extend Circle as Shape {
         *     .perimeter(c: *Circle) f32 = 2 * math.PI * c.radius
         * }
         */
        class extend_declaration : public declaration {
        public:
            /**
             * Construct a new extend declaration object
             * @param range Range in source text
             * @param generic Generic clause
             * @param type_expr Data type which will be extended with declarations
             * @param behaviours Behaviour types whose functions or properties are implemented by the current type
             * @param declarations List of declarations
             */
            extend_declaration(source_range range, pointer<ast::declaration> generic, pointer<ast::expression> type_expr, pointers<ast::expression> behaviours, pointers<ast::declaration> declarations);
            /**
             * Destroys the declaration object
             */
            ~extend_declaration();
            /**
             * @return Generic clause
             */
            pointer<ast::declaration> generic() const;
            /**
             * @return Data type which will be extended with declarations
             */
            pointer<ast::expression>& type_expression() const;
            /**
             * @return Implemented behaviours
             */
            pointers<ast::expression>& behaviours() const;
            /**
             * @return List of declarations
             */
            pointers<ast::declaration>& declarations() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a declaration
             */
            pointer<declaration> clone() const 
            { 
                auto result = create<extend_declaration>(range_, generic_ ? generic_->clone() : nullptr, type_expr_->clone(), ast::clone(behaviours_), ast::clone(declarations_));
                result->annotation_ = annotation_;
                result->hidden(is_hidden());
                return result;
            }
            pointer<statement> sclone() const { return clone(); }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::extend_declaration; } 
        private:
            /**
             * Generic clause
             */
            pointer<ast::declaration> generic_;
            /**
             * Data type
             */
            mutable pointer<ast::expression> type_expr_;
            /**
             * Implemented behaviour 
             */
            mutable pointers<ast::expression> behaviours_;
            /**
             * List of declarations associated to the data type
             */
            mutable pointers<ast::declaration> declarations_;
        };
        /**
         * A behaviour is like a Java interface so it is a collection
         * of functions and properties (abstract or not). For example
         * `behaviour MotorEngine {
         *     // starts the engine
         *     start(m: *MotorEngine)
         *     // stops the engine
         *     stop(m: *MotorEngine)
         *     // downshifts and returns last gear
         *     downshift(m: *MotorEngine) int
         *     // brakes for some time, returns true if it stopped
         *     brake(m: *MotorEngine, millis: natural64) bool
         * }`
         * represents a motor engine behaviour
         */
        class behaviour_declaration : public type_declaration {
        public:
            /**
             * Constructs a new behaviour declaration object
             * @param range Range in source code 
             * @param generic Generic clause
             * @param name Behaviour name
             * @param declarations List of declarations (functions or properties)
             */
            behaviour_declaration(source_range range, pointer<ast::declaration> generic, token name, pointers<ast::declaration> declarations);
            /**
             * Destroys the declaration object
             */
            ~behaviour_declaration();
            /**
             * @return List of function or properties declarations (eventually abstract)
             */
            pointers<ast::declaration>& declarations() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a declaration
             */
            pointer<declaration> clone() const 
            { 
                auto result = create<behaviour_declaration>(range_, generic() ? generic()->clone() : nullptr, name(), ast::clone(declarations_));
                result->annotation_ = annotation_;
                result->hidden(is_hidden());
                return result;
            }
            pointer<statement> sclone() const { return clone(); }

            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::behaviour_declaration; } 
        private:
            /**
             * List of declarations
             */
            mutable pointers<ast::declaration> declarations_;
        };
        /**
         * An extern declaration is a collection of declarations (C functions) defined
         * in another C compilation unit. For example
         * `extern {
         *     // C function with external linkage
         *     function memcpy(dest: *[byte], src: *[byte], size: usize)
         * }`
         */
        class extern_declaration : public declaration {
        public:
            /**
             * Constructs a new extern declaration object
             * @param range Range in source code
             * @param declarations Collection of functions with external linkage
             */
            extern_declaration(source_range range, pointers<ast::declaration> declarations);
            /**
             * Destroys the declaration object
             */
            ~extern_declaration();
            /**
             * @return Collection of functions with external linkage
             */
            pointers<ast::declaration>& declarations() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a declaration
             */
            pointer<declaration> clone() const 
            { 
                auto result = create<extern_declaration>(range_, ast::clone(declarations_));
                result->annotation_ = annotation_;
                result->hidden(is_hidden());
                return result;
            }
            pointer<statement> sclone() const { return clone(); }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::extern_declaration; } 
        private:
            /**
             * Collection of functions with external linkage
             */
            mutable pointers<ast::declaration> declarations_;
        };
        /**
         * A range type is a numeric type which must be within some constraints. For example
         * `type Prime = range 2 | 3 | 5 | 7 | 11 | 13 | 17 | 19
         *  type DangerousTemperatures = ..=-20.0 | 40.0..`
         */
        class range_declaration : public type_declaration {
        public:
            /**
             * Constructs a new range declaration object
             * @param range Range in source text
             * @param name Range name
             * @param generic Generic clause
             * @param constraints Constraint expression, like `0..`, `1..10`, ecc 
             */
            range_declaration(source_range range, token name, pointer<ast::declaration> generic, pointer<ast::expression> constraint);
            /**
             * Destroys the declaration object
             */
            ~range_declaration();
            /**
             * @return Range constraint
             */
            pointer<ast::expression>& constraint() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a declaration
             */
            pointer<declaration> clone() const 
            {
                auto result = create<range_declaration>(range_, name(), generic() ? generic()->clone() : nullptr, constraint_->clone());
                result->annotation_ = annotation_;
                result->hidden(is_hidden());
                return result;
            }
            pointer<statement> sclone() const { return clone(); }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::range_declaration; } 
        private:
            /**
             * Contraint expression
             */
            mutable pointer<ast::expression> constraint_;
        };
        /**
         * A record can be a data (C struct) or union. Here's an example
         * // linked list node
         * `type(T) if Default(T) & Print(T) & Compare(T) ListNode(payload: T, next: Maybe(*Link))`
         */
        class record_declaration : public type_declaration {
        public:
            /**
             * Constructs a new record declaration object
             * @param range Range in source text 
             * @param name Record name
             * @param generic Generic clause
             * @param fields Record fields
             * @param is_union Union flag
             */
            record_declaration(source_range range, token name, pointer<ast::declaration> generic, pointers<ast::declaration> fields, bool is_union = false);
            /**
             * Destroys the declaration object
             */
            ~record_declaration();
            /**
             * Tells if record is data (C struct)
             * @return true If record is declared with `data`
             * @return false Otherwise
             */
            bool is_struct() const;
            /**
             * Tells if record is union (C union)
             * @return true If record is declared with `union`
             * @return false Otherwise
             */
            bool is_union() const;
            /**
             * @return Record fields
             */
            pointers<ast::declaration>& fields() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a declaration
             */
            pointer<declaration> clone() const 
            { 
                auto result = create<record_declaration>(range_, name(), generic() ? generic()->clone() : nullptr, ast::clone(fields_), union_);
                result->annotation_ = annotation_;
                result->hidden(is_hidden());
                return result;
            }
            pointer<statement> sclone() const { return clone(); }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::record_declaration; } 
        private:
            /**
             * Union flag
             */
            bool union_;
            /**
             * Record fields
             */
            mutable pointers<ast::declaration> fields_;
        };
        /**
         * A variant is tagged union with different kinds, for example
         * `type Animal is Elephant | Dog | Turtle`
         * where each kind is a data type with an id
         */
        class variant_declaration : public type_declaration {
        public:
            /**
             * Constructs a new variant declaration object
             * @param range Range in source text
             * @param name Variant name
             * @param generic Generic clause
             * @param types Collections of kind types
             */
            variant_declaration(source_range range, token name, pointer<ast::declaration> generic, pointers<ast::expression> types);
            /**
             * Destroys the declaration object
             */
            ~variant_declaration();
            /**
             * @return Collection of variant types
             */
            pointers<ast::expression>& types() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a declaration
             */
            pointer<declaration> clone() const 
            { 
                auto result = create<variant_declaration>(range_, name(), generic() ? generic()->clone() : nullptr, ast::clone(types_));
                result->annotation_ = annotation_;
                result->hidden(is_hidden());
                return result;
            }
            pointer<statement> sclone() const { return clone(); }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::variant_declaration; } 
        private:
            /**
             * Collection of variant kinds
             */
            mutable pointers<ast::expression> types_;
        };
        /**
         * An alias declaration defines a new name for an existing type, for example
         * `use IntVector = Vector<int>`
         */
        class alias_declaration : public type_declaration {
        public:
            /**
             * Constructs a new alias declaration object
             * @param range Range of source code 
             * @param name Alias name
             * @param generic Generic clause
             * @param type_expr Type expression
             */
            alias_declaration(source_range range, token name, pointer<ast::declaration> generic, pointer<ast::expression> type_expr);
            /**
             * Destroys the declaration object
             */
            ~alias_declaration();
            /**
             * @return Type expression
             */
            pointer<ast::expression>& type_expression() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a declaration
             */
            pointer<declaration> clone() const 
            { 
                auto result = create<alias_declaration>(range_, name(), generic() ? generic()->clone() : nullptr, type_expr_->clone());
                result->annotation_ = annotation_;
                result->hidden(is_hidden());
                return result;
            }
            pointer<statement> sclone() const { return clone(); }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::alias_declaration; } 
        private:
            /**
             * Type expression
             */
            mutable pointer<ast::expression> type_expr_;
        };
        /**
         * Use declaration for workspace declarations, for example
         * `use ns.math` for importing an entire workspace
         * `use ns.namespace.vector` for importing a specific declaration
         */
        class use_declaration : public declaration {
        public:
            /**
             * Constructs a new use declaration object
             * @param range Range of source code 
             * @param path Path name of used workspace
             */
            use_declaration(source_range range, token path);
            /**
             * Destroys the declaration object
             */
            ~use_declaration();
            /**
             * @return Path name of used workspace
             */
            token& path() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a declaration
             */
            pointer<declaration> clone() const 
            { 
                auto result = create<use_declaration>(range_, path_);
                result->annotation_ = annotation_;
                result->hidden(is_hidden());
                return result;
            }
            pointer<statement> sclone() const { return clone(); }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::use_declaration; } 
        private:
            /**
             * Path name of used workspace
             */
            mutable token path_;
        };
        /**
         * workspace declaration for specifying to wich workspace a source
         * file belongs, for example `workspace ns.testing` tells that the
         * current file belongs to the ns.testing workspace
         */
        class workspace_declaration : public declaration {
        public:
            /**
             * Constructs a new workspace declaration object
             * @param range Range of source text
             * @param path Path name of workspace
             */
            workspace_declaration(source_range range, token path);
            /**
             * Destroys the declaration object
             */
            ~workspace_declaration();
            /**
             * @return Path name of workspace
             */
            token& path() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone a declaration
             */
            pointer<declaration> clone() const 
            { 
                auto result = create<workspace_declaration>(range_, path_);
                result->annotation_ = annotation_;
                result->hidden(is_hidden());
                return result;
            }
            pointer<statement> sclone() const { return clone(); }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::workspace_declaration; } 
        private:
            /**
             * Path name of workspace
             */
            mutable token path_;
        };
        /**
         * Source unit declaration, which is a source file declaration
         * containing information about workspace to which the fle belongs,
         * useed names and statements
         */
        class source_unit_declaration : public declaration {
        public:
            /**
             * Annotation for source unit
             */
            struct annotation {
                /**
                 * workspace which hold the declarations of this AST
                 */
                ast::workspace* workspace = nullptr;
            };
            /**
             * Constructs a new source unit declaration object
             * @param range Range of source code, which is the whole source file
             * @param workspace workspace declaration, if any
             * @param imports Imported workspacees
             * @param statements Statements
             */
            source_unit_declaration(source_range range, pointer<ast::statement> workspace, pointers<ast::statement> imports, pointers<ast::statement> statements);
            /**
             * Destroys the declaration object
             */
            ~source_unit_declaration();
            /**
             * @return workspace declaration
             */
            pointer<ast::statement> workspace() const;
            /**
             * @return USe declarations
             */
            pointers<ast::statement>& imports() const;
            /**
             * @return Statements
             */
            pointers<ast::statement>& statements() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * @return Annotation
             */
            source_unit_declaration::annotation& annotation() const { return annotation_; }
            /**
             * Clone a declaration
             */
            pointer<declaration> clone() const 
            { 
                auto result = create<source_unit_declaration>(range_, workspace_ ? workspace_->sclone() : nullptr, ast::clone(imports_), ast::clone(statements_));
                result->annotation_ = annotation_;
                result->hidden(is_hidden());
                return result; 
            }
            pointer<statement> sclone() const { return clone(); }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::source_unit_declaration; } 
        private:
            /**
             * workspace declaration 
             */
            pointer<ast::statement> workspace_;
            /**
             * Import declarations 
             */
            mutable pointers<ast::statement> imports_;
            /**
             * Statements
             */
            mutable pointers<ast::statement> statements_;
            /**
             * Annotation
             */
            mutable struct annotation annotation_;
        };
        /**
         * A type expression is the root for type annotations
         */
        class type_expression : public expression {
        protected:
            /**
             * Constructs a new type expression object
             * @param range Source range in code
             */
            type_expression(source_range range);
            /**
             * Mutability bit
             */
            bool mutable_ : 1;
        public:
            /**
             * A type annotation is ambiguos if it can be either a type
             * either an expression so it is used for generic arguments
             * when the parser doesn't know if an expression is a type
             * or an expression
             * @return true True if it can be both a type or an expression
             * @return false Otherwise
             */
            virtual bool is_ambiguous() const = 0;
            /**
             * A type annotation is parametric if it contains any parametric
             * type defined inside a generic clause (must be annotated)
             * @return true True if it contains parametric types or constants
             * @return false Otherwise
             */
            virtual bool is_parametric() const = 0;
            /**
             * If a type expression is ambiguos then it is converted to an
             * expression like a tuple, array or other
             * @return expression If it is ambiguos
             * @return nullptr Otherwise
             */
            virtual pointer<expression> as_expression() const = 0;
            /**
             * Tells if a type expression looks like a path
             * @return true If type expression looks like a path
             * @return false Otherwise
             */
            virtual bool is_path() const = 0;
            /**
             * A type annotation is never assignable
             * @return false Always
             */
            virtual bool is_assignable() const = 0;
            /**
             * Destroys the type expression object
             */
            virtual ~type_expression();
            /**
             * Clears flags recursively
             */
            virtual void clear() const { annotation().type = nullptr; }
            /**
             * @return Mutability bit when type is annotated with 'mutable'
             */
            bool is_mutable() const { return mutable_; }
            /**
             * Sets mutability bit
             */
            void set_mutable(bool flag) { mutable_ = flag; }
        };
        /**
         * Type of record bit field, for example
         * `data Registers(r0: 32, r1: 32)` declares
         * a data type with two fields of 32 bits 
         */
        class bit_field_type_expression : public type_expression {
        public:
            /**
             * Constructs a new bit field type expression object
             * @param value Value as size in bits of record field
             */
            bit_field_type_expression(token value);
            /**
             * Destroys the type expression object
             */
            ~bit_field_type_expression();
            /**
             * @return Size of bit field in bits
             */
            token& size() const;
            /**
             * @return true Always as it can be a literal expression
             */
            bool is_ambiguous() const;
            /**
             * @return false Always
             */
            bool is_parametric() const;
            /**
             * @return literal expression
             */
            pointer<expression> as_expression() const;
            /**
             * @return false Always 
             */
            bool is_path() const;
            /**
             * A type annotation is never assignable
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<expression> clone() const 
            { 
                auto result = create<bit_field_type_expression>(size_);
                result->annotation_ = annotation_;
                result->mutable_ = mutable_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::bit_field_type_expression; } 
        private:
            /**
             * Size in bits of the record field
             */
            mutable token size_;
        };
        /**
         * Path type is like `A.B(T, 10)` or `A.B` or `A`
         */
        class path_type_expression : public type_expression {
        public:
            /**
             * Constructs a new path type expression object
             * @param range Range of source code
             * @param expr Left expression
             * @param member Member expression
             */
            path_type_expression(source_range range, pointer<ast::expression> expr, pointer<ast::expression> member);
            /**
             * Destroys the expression object
             */
            ~path_type_expression();
            /**
             * @return Left expression
             */
            pointer<ast::expression>& expression() const;
            /**
             * A member expression could be a simple name like `A.B` or `A.B(i32)`
             * @return Member expression
             */
            pointer<ast::expression>& member() const;
            /**
             * @return true If left expression is a path
             */
            bool is_path() const;
            /**
             * @return true Always
             */
            bool is_assignable() const;
            /**
             * @return true If all ambiguos
             */
            bool is_ambiguous() const;
            /**
             * @return true If type annotation tells it is generic
             */
            bool is_parametric() const;
            /**
             * @return identifier expression or function call
             */
            pointer<ast::expression> as_expression() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<ast::expression> clone() const 
            { 
                auto result = create<path_type_expression>(range_, expr_->clone(), member_ ? member_->clone() : nullptr); 
                result->annotation_ = annotation_;
                result->mutable_ = mutable_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::path_type_expression; }
            /**
             * Clears flags recursively
             */
            virtual void clear() const 
            {
                annotation().type = nullptr;
                if (auto texpr = std::dynamic_pointer_cast<ast::type_expression>(expr_)) texpr->clear();
                else expr_->annotation().type = nullptr;
                if (member_) member_->annotation().type = nullptr;
            }
        private:
            /**
             * Left expression
             */
            mutable pointer<ast::expression> expr_;
            /**
             * Member expression
             */
            mutable pointer<ast::expression> member_;
        };

        /**
         * An array type expression, which could be
         * `[int]` for dynamic-sized or inferred size arrays
         * `[int: 10]` for coercied size arrays
         */
        class array_type_expression : public type_expression {
        public:
            /**
             * Constructs a new array type expression object
             * @param range Range of source code
             * @param element_ty Element type
             * @param size Size of array, if any
             */
            array_type_expression(source_range range, pointer<ast::expression> element_ty, pointer<ast::expression> size);
            /**
             * Destroys the type expression object
             */
            ~array_type_expression();
            /**
             * @return Element type
             */
            pointer<ast::expression>& element_type() const;
            /**
             * @return Size of array
             */
            pointer<ast::expression>& size() const;
            /**
             * @return true If array size is specified
             */
            bool is_sized() const;
            /**
             * @return true If is has no size specified it could be a one element array expression
             */
            bool is_ambiguous() const;
            /**
             * @return true If type annotation tells it is generic
             */
            bool is_parametric() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * A type annotation is never assignable
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * @return array sized expression or one element array
             */
            pointer<expression> as_expression() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<expression> clone() const 
            { 
                auto result = create<array_type_expression>(range_, element_type_->clone(), size_ ? size_->clone() : nullptr);
                result->annotation_ = annotation_;
                result->mutable_ = mutable_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::array_type_expression; } 
            /**
             * Clears flags recursively
             */
            virtual void clear() const 
            {
                annotation().type = nullptr;
                if (auto texpr = std::dynamic_pointer_cast<ast::type_expression>(element_type_)) texpr->clear();
            }
        private:
            /**
             * Element type
             */
            mutable pointer<ast::expression> element_type_;
            /**
             * Array size 
             */
            mutable pointer<ast::expression> size_;
        };
        /**
         * Tuple type expression, like `(A, B, C)`
         */
        class tuple_type_expression : public type_expression {
        public:
            /**
             * Constructs a new tuple type expression object
             * @param range Range of source code 
             * @param types Type annotations of tuple types
             */
            tuple_type_expression(source_range range, pointers<ast::expression> types);
            /**
             * Destroys the type expression object
             */
            ~tuple_type_expression();
            /**
             * @return Tuple type annotations
             */
            pointers<ast::expression>& types() const;
            /**
             * @return true If could be a tuple expression
             */
            bool is_ambiguous() const;
            /**
             * @return true If type annotation contains parametric types
             */
            bool is_parametric() const;
            /**
             * @return tuple expression or parenthesis expression
             */
            pointer<expression> as_expression() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * A type annotation is never assignable
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<expression> clone() const 
            { 
                auto result = create<tuple_type_expression>(range_, ast::clone(types_));
                result->annotation_ = annotation_;
                result->mutable_ = mutable_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::tuple_type_expression; } 
            /**
             * Clears flags recursively
             */
            virtual void clear() const 
            {
                annotation().type = nullptr;
                for (auto t : types_) if (auto texpr = std::dynamic_pointer_cast<ast::type_expression>(t)) texpr->clear();
            }
        private:
            /**
             * Tuple elements types annotations
             */
            mutable pointers<ast::expression> types_;
        };
        /**
         * Tuple type expression, like `(a: A, b: B, c: C)`
         */
        class record_type_expression : public type_expression {
        public:
            /**
             * Constructs a new record declaration object
             * @param range Range in source text
             * @param fields Record fields
             */
            record_type_expression(source_range range, pointers<ast::declaration> fields);
            /**
             * Destroys the type expression object
             */
            ~record_type_expression();
            /**
             * @return true If could be a record initializer expression
             */
            bool is_ambiguous() const;
            /**
             * @return true If type annotation contains parametric types
             */
            bool is_parametric() const;
            /**
             * @return Record expression
             */
            pointer<expression> as_expression() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * A type annotation is never assignable
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * @return Record fields
             */
            pointers<ast::declaration>& fields() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<expression> clone() const 
            { 
                auto result = create<record_type_expression>(range_, ast::clone(fields_));
                result->annotation_ = annotation_;
                result->mutable_ = mutable_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::record_type_expression; } 
            /**
             * Clears flags recursively
             */
            virtual void clear() const 
            {
                annotation().type = nullptr;
                for (auto f : fields_) {
                    auto field = std::static_pointer_cast<ast::field_declaration>(f);
                    if (auto texpr = std::dynamic_pointer_cast<ast::type_expression>(field->type_expression())) texpr->clear();
                }
            }
        private:
            /**
             * Record fields
             */
            mutable pointers<ast::declaration> fields_;
        };
        /**
         * Function type annotation, like `function(int) float`
         */
        class function_type_expression : public type_expression {
        public:
            /**
             * Constructs a new function type expression object
             * @param range Range of source code
             * @param parameter_ty Parameter types annotations
             * @param return_ty Return type annotation
             */
            function_type_expression(source_range range, pointers<ast::expression> parameter_ty, pointer<ast::expression> return_ty);
            /**
             * Destroys the type expression object
             */
            ~function_type_expression();
            /**
             * @return Parameter types annotations
             */
            pointers<ast::expression>& parameter_types() const;
            /**
             * @return Return type annotation
             */
            pointer<ast::expression>& return_type_expression() const;
            /**
             * @return false Always
             */
            bool is_ambiguous() const;
            /**
             * @return true If type annotation contains parametric types
             */
            bool is_parametric() const;
            /**
             * @return nullptr
             */
            pointer<expression> as_expression() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * A type annotation is never assignable
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<expression> clone() const 
            { 
                auto result = create<function_type_expression>(range_, ast::clone(parameter_types_), return_type_ ? return_type_->clone() : nullptr);
                result->annotation_ = annotation_;
                result->mutable_ = mutable_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::function_type_expression; } 
            /**
             * Clears flags recursively
             */
            virtual void clear() const 
            {
                annotation().type = nullptr;
                if (auto result = std::dynamic_pointer_cast<ast::type_expression>(return_type_)) result->clear();
                for (auto p : parameter_types_) if (auto texpr = std::dynamic_pointer_cast<ast::type_expression>(p)) texpr->clear();
            }
        private:
            /**
             * Parameter types annotations
             */
            mutable pointers<ast::expression> parameter_types_;
            /**
             * Return type annotation
             */
            mutable pointer<ast::expression> return_type_;
        };
        /**
         * Raw pointer type annotation, like `*int`
         */
        class pointer_type_expression : public type_expression {
        public:
            /**
             * Constructs a new pointer type expression object
             * @param range Range of source code
             * @param pointee_ty Pointee type annotation
             */
            pointer_type_expression(source_range range, pointer<ast::expression> pointee_ty);
            /**
             * Destroys the type expression object
             */
            ~pointer_type_expression();
            /**
             * @return Pointee type annotation
             */
            pointer<ast::expression>& pointee_type() const;
            /**
             * @return true If pointee type is ambiguos (could be a dereference expression)
             */
            bool is_ambiguous() const;
            /**
             * @return true If type annotation contains parametric types
             */
            bool is_parametric() const;
            /**
             * @return Dereference (unary) expression
             */
            pointer<expression> as_expression() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * A type annotation is never assignable
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<expression> clone() const 
            { 
                auto result = create<pointer_type_expression>(range_, pointee_type_->clone()); 
                result->annotation_ = annotation_;
                result->mutable_ = mutable_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::pointer_type_expression; } 
            /**
             * Clears flags recursively
             */
            virtual void clear() const 
            {
                annotation().type = nullptr;
                if (auto pointee = std::dynamic_pointer_cast<ast::type_expression>(pointee_type_)) pointee->clear();
            }
        private:
            /**
             * Pointee type annotation
             */
            mutable pointer<ast::expression> pointee_type_;
        };
        /**
         * Variant type annotation is used for sum types, for example
         * a variable which could be either an integer or string is declared
         * this way: `val either: i32 | string = get_value()`
         */
        class variant_type_expression : public type_expression {
        public:
            /**
             * Constructs a type expression object
             * @param range Range in source text
             * @param types Sum types
             */
            variant_type_expression(source_range range, pointers<ast::expression> types);
            /**
             * Destroys the type expression object
             */
            ~variant_type_expression();
            /**
             * @return Parameter type
             */
            pointers<ast::expression>& types() const;
            /**
             * @return true If all sum type expressions are ambigous
             */
            bool is_ambiguous() const;
            /**
             * @return true If type annotation contains parametric types
             */
            bool is_parametric() const;
            /**
             * @return Or expression
             */
            pointer<expression> as_expression() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * A type annotation is never assignable
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<expression> clone() const 
            { 
                auto result = create<variant_type_expression>(range_, ast::clone(types_)); 
                result->annotation_ = annotation_;
                result->mutable_ = mutable_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::variant_type_expression; }
            /**
             * Clears flags recursively
             */
            virtual void clear() const 
            {
                annotation().type = nullptr;
                for (auto t : types_) if (auto texpr = std::dynamic_pointer_cast<ast::type_expression>(t)) texpr->clear();
            }
        private:
            /**
             * Sum types
             */
            mutable pointers<ast::expression> types_;
        };
        /**
         * Literal value expression, like `10`, `"hello!"`, ecc
         */
        class literal_expression : public expression {
        public:
            /**
             * Constructs a new literal expression object
             * @param value Literal value 
             */
            literal_expression(token value);
            /**
             * Destroys the expression object
             */
            ~literal_expression();
            /**
             * @return Literal value
             */
            token& value() const;
            /**
             * @return true If value is `true` or `false`
             */
            bool is_boolean() const;
            /**
             * @return true If value is a character literal
             */
            bool is_character() const;
            /**
             * @return true If value is a string primitive literal without `s` suffix
             */
            bool is_string_primitive() const;
            /**
             * @return true If value is a string literal with or without `s` suffix
             */
            bool is_string() const;
            /**
             * @return true If value is an integer literal
             */
            bool is_integer() const;
            /**
             * @return true If value is a real literal
             */
            bool is_real() const;
            /**
             * @return true If value is an imaginary literal
             */
            bool is_imaginary() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<expression> clone() const 
            { 
                auto result = create<literal_expression>(value_); 
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::literal_expression; } 
        private:
            /**
             * Literal value
             */
            mutable token value_;
        };
        /**
         * Identifier expression, like `var_name` or `vector!(int)`
         */
        class identifier_expression : public expression {
        public:
            /**
             * Constructs a new identifier expression object
             * @param range Range in source code
             * @param value Identifier name
             * @param generics Generics argument, if any, between `!(` and `)`
             * @param is_generic Tells if there is a generic clause after the identifier
             */
            identifier_expression(source_range range, token value, pointers<ast::expression> generics, bool is_generic = false);
            /**
             * Destroys the expression object
             */
            ~identifier_expression();
            /**
             * @return Identifier name
             */
            token& identifier() const;
            /**
             * @return true If identifier is `_`
             * @return false Otherwise
             */
            bool is_underscore() const;
            /**
             * In an expression like `array!(bool, 10 * 10)` then `bool` and `10 * 10` are
             * generic arguments
             * @return Generic arguments
             */
            pointers<ast::expression>& generics() const;
            /**
             * When there is an object construction, an expression like `array!(real, 100)`
             * contains generic arguments
             * @return true If there is generic clause starting with `!`
             * @return false Otherwise
             */
            bool is_generic() const;
            /**
             * @return true Always
             */
            bool is_path() const;
            /**
             * @return true Always
             */
            bool is_assignable() const;
            /**
             * Returns the immutable variable which it references, if any
             * 
             * @return Immutable variabile it references, if any
             */
            virtual const ast::declaration* immutable() const
            {
                if (!annotation().referencing) return nullptr;
                
                switch (annotation().referencing->kind()) {
                    case ast::kind::var_declaration:
                    case ast::kind::parameter_declaration:
                        return static_cast<const ast::var_declaration*>(annotation().referencing)->is_mutable() ? nullptr : annotation().referencing;
                    case ast::kind::generic_const_parameter_declaration:
                    case ast::kind::const_declaration:
                    case ast::kind::function_declaration:
                    case ast::kind::property_declaration:
                        return annotation().referencing;
                    default:
                        break;
                }
                
                return nullptr;
            }
            /**
             * Returns the referencing variable it references, if any
             * 
             * @return Referencing variable, if any
             */
            virtual const ast::declaration* lvalue() const
            {
                if (!annotation().referencing) return nullptr;
                
                switch (annotation().referencing->kind()) {
                    case ast::kind::var_declaration:
                    case ast::kind::parameter_declaration:
                    case ast::kind::function_declaration:
                    case ast::kind::property_declaration:
                    case ast::kind::field_declaration:
                    case ast::kind::tuple_field_declaration:
                        return annotation().referencing;
                    default:
                        break;
                }
                
                return nullptr;
            }
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<expression> clone() const 
            { 
                auto result = create<identifier_expression>(range_, value_, ast::clone(generics_), generic_); 
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::identifier_expression; } 
        private:
            /**
             * Identifier name
             */
            mutable token value_;
            /**
             * Generic arguments
             */
            mutable pointers<ast::expression> generics_;
            /**
             * Generic flag 
             */
            bool generic_;
        };
        /**
         * Tuple expression, like `(1, "hello", 0.1i)`
         */
        class tuple_expression : public expression {
        public:
            /**
             * Constructs a new tuple expression object
             * @param range Range of source code
             * @param elements Tuple elements expressions
             */
            tuple_expression(source_range range, pointers<ast::expression> elements);
            /**
             * Destroys the expression object
             */
            ~tuple_expression();
            /**
             * @return Elements expressions
             */
            pointers<ast::expression>& elements() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * @return true If all the elements are assignable
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<expression> clone() const 
            { 
                auto result = create<tuple_expression>(range_, ast::clone(elements_));
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::tuple_expression; }
        private:
            /**
             * Elements expressions
             */
            mutable pointers<ast::expression> elements_;
        };
        /**
         * Array expression, like `[1, 2, 3]`
         */
        class array_expression : public expression {
        public:
            /**
             * Constructs a new array expression object
             * @param range Code of source range 
             * @param elements Elements expressions
             */
            array_expression(source_range range, pointers<ast::expression> elements);
            /**
             * Destroys the expression object
             */
            ~array_expression();
            /**
             * @return Elements expressions
             */
            pointers<ast::expression>& elements() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<expression> clone() const 
            { 
                auto result = create<array_expression>(range_, ast::clone(elements_)); 
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::array_expression; } 
        private:
            /**
             * Elements expressions
             */
            mutable pointers<ast::expression> elements_;
        };
        /**
         * Sized array constructor expression, like `[value: n]`
         * which constructs an array of `n` values all initialized
         * to `value`
         */
        class array_sized_expression : public expression {
        public:
            /**
             * Constructs a new array sized expression object
             * @param range Range of source code 
             * @param value Initial value
             * @param size Sie of array
             */
            array_sized_expression(source_range range, pointer<ast::expression> value, pointer<ast::expression> size);
            /**
             * Destroys the expression object
             */
            ~array_sized_expression();
            /**
             * @return Intial value
             */
            pointer<ast::expression>& value() const;
            /**
             * @return Array size
             */
            pointer<ast::expression>& size() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<expression> clone() const 
            { 
                auto result = create<array_sized_expression>(range_, value_->clone(), size_->clone()); 
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::array_sized_expression; } 
        private:
            /**
             * Initializer value
             */
            mutable pointer<ast::expression> value_;
            /**
             * Array size
             */
            mutable pointer<ast::expression> size_;
        };
        /**
         * Parathesis expression, like `(1 + 2)` and can never be a one sized tuple
         */
        class parenthesis_expression : public ast::expression {
        public:
            /**
             * Constructs a new parenthesis expression object
             * @param range Range of source code 
             * @param expr Contained expression
             */
            parenthesis_expression(source_range range, pointer<ast::expression> expr);
            /**
             * Destroys the expression object
             */
            ~parenthesis_expression();
            /**
             * @return Contained expression
             */
            pointer<ast::expression>& expression() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<ast::expression> clone() const 
            { 
                auto result = create<parenthesis_expression>(range_, expr_->clone());
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * Returns the immutable variable which it references, if any
             * 
             * @return Immutable variabile it references, if any
             */
            virtual const ast::declaration* immutable() const { return expr_->immutable(); }
            /**
             * Returns the referencing variable it references, if any
             * 
             * @return Referencing variable, if any
             */
            virtual const ast::declaration* lvalue() const { return expr_->lvalue(); }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::parenthesis_expression; } 
        private:
            /**
             * Contained expression
             */
            mutable pointer<ast::expression> expr_;
        };
        /**
         * Block expression, for example `{...}` or `=> f();` whose value
         * is the last expression statement value, if any 
         */
        class block_expression : public expression {
        public:
            block_expression(source_range range, pointers<ast::statement> stms);
            /**
             * Destroys the expression object
             */
            ~block_expression();
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * @return Contained statements
             */
            pointers<ast::statement>& statements() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<expression> clone() const 
            { 
                auto result = create<block_expression>(range_, ast::clone(statements_)); 
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Reference to annotation
             */
            const ast::node*& exprnode() const { return exprnode_; }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::block_expression; } 
        private:
            /**
             * Contained statements
             */
            mutable pointers<ast::statement> statements_;
            /**
             * Annotation for expression node
             */
            mutable const ast::node* exprnode_ = nullptr;
        };
        /**
         * Function expression which cannot capture local environment, for example
         * `function factorial(n: int) int {...}`
         */
        class function_expression : public expression {
        public:
            /**
             * Constructs a new function expression object
             * @param range Range of source code
             * @param parameters Function parameters
             * @param return_type_expression Return type annotation
             * @param body Function body
             */
            function_expression(source_range range, pointers<ast::declaration> parameters, pointer<ast::expression> return_type_expression, pointer<ast::expression> body);
            /**
             * Destroys the expression object
             */
            ~function_expression();
            /**
             * @return Function parameters
             */
            pointers<ast::declaration>& parameters() const;
            /**
             * @return Return type annotation
             */
            pointer<ast::expression>& return_type_expression() const;
            /**
             * @return Function body
             */
            pointer<ast::expression>& body() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<expression> clone() const 
            { 
                auto result = create<function_expression>(range_, ast::clone(parameters_), return_type_ ? return_type_->clone() : nullptr, body_->clone());
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::function_expression; }
            /**
             * Source range of result type, if any
             */
            source_range& result_range() const { return result_range_; }
            /**
             * List of captured variables
             */
            std::set<const var_declaration*>& captured() const { return captured_; }
        private:
            /**
             * Funtion parameters
             */
            mutable pointers<ast::declaration> parameters_;
            /**
             * Return type annotation
             */
            mutable pointer<ast::expression> return_type_;
            /**
             * Function body
             */
            mutable pointer<ast::expression> body_;
            /**
             * Range of result type
             */
            mutable source_range result_range_;
            /**
             * List of captured variables
             */
            mutable std::set<const var_declaration*> captured_ = {};
        };
        /**
         * Postfix expression, like `i++` or `i--`
         */
        class postfix_expression : public ast::expression {
        public:
            /**
             * Constructs a new postfix expression object
             * @param range Range of source code
             * @param expr Left expression
             * @param postfix Postifix operator (`++`, `--`)
             */
            postfix_expression(source_range range, pointer<ast::expression> expr, token postfix);
            /**
             * Destroys the expression object
             */
            ~postfix_expression();
            /**
             * @return Left expression
             */
            pointer<ast::expression>& expression() const;
            /**
             * @return Postfix operator
             */
            token& postfix() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * @return false ALways
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<ast::expression> clone() const 
            { 
                auto result = create<postfix_expression>(range_, expr_->clone(), postfix_);
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::postfix_expression; }
            /**
             * Returns the immutable variable which it references, if any
             * 
             * @return Immutable variabile it references, if any
             */
            virtual const ast::declaration* immutable() const { return expr_->immutable(); }
            /**
             * Returns the referencing variable it references, if any
             * 
             * @return Referencing variable, if any
             */
            virtual const ast::declaration* lvalue() const { return expr_->lvalue(); }
        private:
            /**
             * Left expression
             */
            mutable pointer<ast::expression> expr_;
            /**
             * Postfix operator
             */
            mutable token postfix_;
        };
        /**
         * Call expression, like `a.b()` or `f(1)`
         */
        class call_expression : public ast::expression {
        public:
            /**
             * Constructs a new call expression object
             * @param range Range of source code
             * @param callee Left expression
             * @param args Arguments
             */
            call_expression(source_range range, pointer<ast::expression> callee, pointers<ast::expression> args);
            /**
             * Destroys the expression object
             */
            ~call_expression();
            /**
             * @return Callee expression
             */
            pointer<ast::expression>& callee() const;
            /**
             * @return Call arguments
             */
            pointers<ast::expression>& arguments() const;
            /**
             * @return true If left expression is a field expression
             */
            bool is_method_call() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * @return true Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<ast::expression> clone() const 
            { 
                auto result = create<call_expression>(range_, callee_->clone(), ast::clone(args_));
                result->annotation_ = annotation_;
                return result; 
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::call_expression; }
        private:
            /**
             * Callee expression
             */
            mutable pointer<ast::expression> callee_;
            /**
             * Arguments
             */
            mutable pointers<ast::expression> args_;
        };
        /**
         * Field expression, like `f().a`
         */
        class member_expression : public ast::expression {
        public:
            /**
             * Constructs a new field expression object
             * @param range Range of source code
             * @param expr Left expression
             * @param member Member expression
             */
            member_expression(source_range range, pointer<ast::expression> expr, pointer<ast::expression> member);
            /**
             * Destroys the expression object
             */
            ~member_expression();
            /**
             * @return Left expression
             */
            pointer<ast::expression>& expression() const;
            /**
             * A member expression could be a simple name like `structure.field`, `package.name`
             * or a more elaborated generic type or function like `math.random!(int)` or `math.matrix!(real, 3, 4)`
             * @return Member expression
             */
            pointer<ast::expression>& member() const;
            /**
             * @return true If left expression is a path
             */
            bool is_path() const;
            /**
             * @return true Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<ast::expression> clone() const 
            { 
                auto result = create<member_expression>(range_, expr_->clone(), member_->clone()); 
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::member_expression; }
            /**
             * Returns the immutable variable which it references, if any
             * 
             * @return Immutable variabile it references, if any
             */
            virtual const ast::declaration* immutable() const { return expr_->immutable(); }
            /**
             * Returns the referencing variable it references, if any
             * 
             * @return Referencing variable, if any
             */
            virtual const ast::declaration* lvalue() const { return expr_->lvalue(); }
        private:
            /**
             * Left expression
             */
            mutable pointer<ast::expression> expr_;
            /**
             * Member expression
             */
            mutable pointer<ast::expression> member_;
        };
        /**
         * Array indexing, like `array[10]`
         */
        class array_index_expression : public ast::expression {
        public:
            /**
             * Constructs a new array index expression object
             * @param range Range of source code
             * @param expr Left expression
             * @param index Index expression
             */
            array_index_expression(source_range range, pointer<ast::expression> expr, pointer<ast::expression> index);
            /**
             * Destroys the expression object
             */
            ~array_index_expression();
            /**
             * @return Left expression
             */
            pointer<ast::expression>& expression() const;
            /**
             * @return Index expression
             */
            pointer<ast::expression>& index() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * @return true Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<ast::expression> clone() const 
            {
                auto result = create<array_index_expression>(range_, expr_->clone(), index_->clone());
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::array_index_expression; }
            /**
             * Returns the immutable variable which it references, if any
             * 
             * @return Immutable variabile it references, if any
             */
            virtual const ast::declaration* immutable() const { return expr_->immutable(); }
            /**
             * Returns the referencing variable it references, if any
             * 
             * @return Referencing variable, if any
             */
            virtual const ast::declaration* lvalue() const { return expr_->lvalue(); }
        private:
            /**
             * Left expression
             */
            mutable pointer<ast::expression> expr_;
            /**
             * Index expression
             */
            mutable pointer<ast::expression> index_;
        };
        /**
         * Tuple index, for example `pair.0` where index is an integer
         */
        class tuple_index_expression : public ast::expression {
        public:
            /**
             * Constructs a new tuple index expression object
             * @param range Range of source code 
             * @param expr Left expression
             * @param index Index number
             */
            tuple_index_expression(source_range range, pointer<ast::expression> expr, token index);
            /**
             * Destroys the expression object
             */
            ~tuple_index_expression();
            /**
             * @return Left expression
             */
            pointer<ast::expression>& expression() const;
            /**
             * @return Index number, which is an integer
             */
            token& index() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * @return true Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<ast::expression> clone() const 
            { 
                auto result = create<tuple_index_expression>(range_, expr_->clone(), index_);
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::tuple_index_expression; }
            /**
             * Returns the immutable variable which it references, if any
             * 
             * @return Immutable variabile it references, if any
             */
            virtual const ast::declaration* immutable() const { return expr_->immutable(); }
            /**
             * Returns the referencing variable it references, if any
             * 
             * @return Referencing variable, if any
             */
            virtual const ast::declaration* lvalue() const { return expr_->lvalue(); }
        private:
            /**
             * Left expression
             */
            mutable pointer<ast::expression> expr_;
            /**
             * Integer index number
             */
            mutable token index_;
        };
        /**
         * Record expression, like `user(name: "John Doe", age: 35)` or `(a: 1, b: 2)`
         */
        class record_expression : public ast::expression {
        public:
            /**
             * Initializer for a single field, a pair of field name and expression
             */
            class initializer {
            public:
                /**
                 * Constructs a new initializer object
                 * @param field Field name
                 * @param init Field value
                 */
                initializer(token field, pointer<ast::expression> init);
                /**
                 * Destroys the initializer object
                 */
                ~initializer();
                /**
                 * @return Field name
                 */
                token& field() const;
                /**
                 * @return Field value
                 */
                pointer<ast::expression>& value() const;
            private:
                /**
                 * Field name
                 */
                mutable token field_;
                /**
                 * Field value
                 */
                mutable pointer<ast::expression> init_;
            };
            /**
             * Constructs a new record expression object
             * @param range Range of source code
             * @param callee Callee expression
             * @param initializers Fields initializers
             */
            record_expression(source_range range, pointer<ast::expression> callee, std::vector<initializer> initializers);
            /**
             * Destroys the expression object
             */
            ~record_expression();
            /**
             * @return true If record type is anonymous (callee == nullptr)
             * @return false Otherwise
             */
            bool is_anonymous() const;
            /**
             * @return Callee expression
             */
            pointer<ast::expression>& callee() const;
            /**
             * @return Field initializers
             */
            std::vector<initializer>& initializers() const;
            /**
             * @return false ALways
             */
            bool is_path() const;
            /**
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<ast::expression> clone() const 
            {
                std::vector<initializer> inits;
                for (auto init : inits_) inits.emplace_back(init.field(), init.value()->clone()); 
                auto result = create<record_expression>(range_, callee_ ? callee_->clone() : nullptr, inits);
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::record_expression; } 
        private:
            /**
             * Callee expression
             */
            mutable pointer<ast::expression> callee_;
            /**
             * Fields initializers
             */
            mutable std::vector<initializer> inits_;
        };
        /**
         * Unary expression, like `!cond`, `++index`, `*ptr`, `&value`
         */
        class unary_expression : public ast::expression {
        public:
            /**
             * Constructs a new unary expression object
             * @param range Range of source code
             * @param op Unary operator (`++`, `--`, `+`, `-`, `*`, `&`, `~`, `!`)
             * @param expr Right expression
             */
            unary_expression(source_range range, token op, pointer<ast::expression> expr);
            /**
             * Destroys the expression object
             */
            ~unary_expression();
            /**
             * @return Unary operator (`++`, `--`, `+`, `-`, `*`, `&`, `~`, `!`)
             */
            token& unary_operator() const;
            /**
             * @return Right expression
             */
            pointer<ast::expression>& expression() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * @return true If it is a dereference expression, like `*ptr`
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<ast::expression> clone() const 
            { 
                auto result = create<unary_expression>(range_, op_, expr_->clone());
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::unary_expression; }
            /**
             * Returns the immutable variable which it references, if any
             * 
             * @return Immutable variabile it references, if any
             */
            virtual const ast::declaration* immutable() const { return expr_->immutable(); }
            /**
             * Returns the referencing variable it references, if any
             * 
             * @return Referencing variable, if any
             */
            virtual const ast::declaration* lvalue() const { return expr_->lvalue(); }
        private:
            /**
             * Unary operator
             */
            mutable token op_;
            /**
             * Right expression
             */
            mutable pointer<ast::expression> expr_;
        };
        /**
         * Binary expression, for example `a+b`, `a**b`, `a as b`
         */
        class binary_expression : public ast::expression {
        public:
            /**
             * Constructs a new binary expression object
             * @param range Range of source code 
             * @param op Binary operator (`+`, `-`, `*`, `/`, `**`, `%`, `&`, `|`, `^`, `&&`, `||`, `as`)
             * @param left Left expression
             * @param right Right expression
             */
            binary_expression(source_range range, token op, pointer<ast::expression> left, pointer<ast::expression> right);
            /**
             * Destroys the expression object
             */
            ~binary_expression();
            /**
             * @return Binary operator (`+`, `-`, `*`, `/`, `**`, `%`, `&`, `|`, `^`, `&&`, `||`, `as`)
             */
            token& binary_operator() const;
            /**
             * @return Left expression
             */
            pointer<ast::expression>& left() const;
            /**
             * @return Right expression 
             */
            pointer<ast::expression>& right() const;
            /**
             * @return true If is type conversion with `as` operator
             */
            bool is_conversion() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<ast::expression> clone() const 
            { 
                auto result = create<binary_expression>(range_, op_, left_->clone(), right_->clone());
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::binary_expression; } 
        private:
            /**
             * Binary operator
             */
            mutable token op_;
            /**
             * Left expression
             */
            mutable pointer<ast::expression> left_;
            /**
             * Right expression
             */
            mutable pointer<ast::expression> right_;
        };
        /**
         * This expression is an implicit cast inserted by the compiler.
         * For example, when an array is passed as array slice.
         */
        class implicit_conversion_expression : public ast::expression {
        public:
            /**
             * Constructs a new implict cast expression object
             * @param range Range of source code 
             * @param left Expression
             */
            implicit_conversion_expression(source_range range, pointer<ast::expression> expr);
            /**
             * Destroys the expression object
             */
            ~implicit_conversion_expression();
            /**
             * @return Expression
             */
            pointer<ast::expression>& expression() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<ast::expression> clone() const 
            { 
                auto result = create<implicit_conversion_expression>(range_, expr_->clone());
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::implicit_conversion_expression; } 
        private:
            /**
             * Left expression
             */
            mutable pointer<ast::expression> expr_;
        };
        /**
         * Range expression, like `1..2`, `..`, `1..=10`
         */
        class range_expression : public ast::expression {
        public:
            /**
             * Constructs a new range expression object
             * @param range Range in source text
             * @param op Range operator (`..`, `..=`)
             * @param start Start of range, if any
             * @param end End of range, if any
             */
            range_expression(source_range range, token op, pointer<ast::expression> start, pointer<ast::expression> end);
            /**
             * Destroys the expression object
             */
            ~range_expression();
            /**
             * @return Range operator (`..`, `..=`)
             */
            token& range_operator() const;
            /**
             * @return Start expression, if any
             */
            pointer<ast::expression>& start() const;
            /**
             * @return End expression, if any
             */
            pointer<ast::expression>& end() const;
            /**
             * @return true If has operator `..=`
             */
            bool is_inclusive() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<ast::expression> clone() const 
            { 
                auto result = create<range_expression>(range_, op_, start_ ? start_->clone() : nullptr, end_ ? end_->clone() : nullptr);
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::range_expression; } 
        private:
            /**
             * Range operator
             */
            mutable token op_;
            /**
             * Start expression
             */
            mutable pointer<ast::expression> start_;
            /**
             * End expression
             */
            mutable pointer<ast::expression> end_;
        };
        /**
         * Root class for pattern expressions inside `when` body
         */
        class pattern_expression : public ast::expression {
        protected:
            /**
             * Constructs a new pattern expression object
             * @param range Range of source text 
             */
            pattern_expression(source_range range);
        public:
            /**
             * Destroys the expression object
             */
            virtual ~pattern_expression();
            /**
             * Sets or gets compiled pattern condition
             */
            ast::pointer<ast::expression>& compiled() const { return compiled_; }
        private:
            // condition compiled from pattern
            mutable ast::pointer<ast::expression> compiled_ = nullptr;
        };
        /**
         * In a `when` block we have an path pattern when
         * we see 
         * `when expr {
         *     ...
         *     name => ...
         *     maybe.none => ...
         *     _ => ...
         * }`
         * where name can be a constant (compile-time) or it can be a new variable to which
         * the value of expr is eventually assigned or it can be a variant kind name
         */
        class path_pattern_expression : public pattern_expression {
        public:
            /**
             * Constructs a new path pattern expression object
             * @param path Path name
             */
            path_pattern_expression(ast::pointer<ast::expression> path);
            /**
             * Destroys the expression object
             */
            ~path_pattern_expression();
            /**
             * @return path name 
             */
            ast::pointer<ast::expression>& path() const;
            /**
             * When the value of expression is ignored and not saved,
             * then wildcard `_` is used
             * @return true If path is `_`
             * @return false Otherwise
             */
            bool is_underscore() const;
            /**
             * @return true Always
             */
            bool is_path() const;
            /**
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<ast::expression> clone() const 
            { 
                auto result = create<path_pattern_expression>(path_->clone());
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::path_pattern_expression; } 
        private:
            /**
             * path name
             */
            mutable ast::pointer<ast::expression> path_;
        };
        /**
         * The ignore pattern, which is `...` is used to skip some record fields, tuple or array
         * elements, for example
         * `when expr {
         *      [1, 2, ...] => ...
         *      some(...) => ...
         *      (..., 3, 4)
         * }`
         * It must be the first or last or both pattern inside a record, array or tuple.
         */
        class ignore_pattern_expression : public pattern_expression {
        public:
            /**
             * Constructs a new ignore pattern expression object
             * @param range `...` range in source text
             */
            ignore_pattern_expression(source_range range);
            /**
             * Destroys the expression object
             */
            ~ignore_pattern_expression();
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<ast::expression> clone() const 
            { 
                auto result = create<ignore_pattern_expression>(range_);
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::ignore_pattern_expression; } 
        };
        /**
         * A literal pattern is a literal expression whose branch is chosed
         * when there is a match with the tested expression. For example
         * `when f() {
         *     1 => ...
         *     2 => ...
         *     'a' => ...
         *     "ahahaha" => ...
         * }`
         * all branches' patterns are literal patterns
         */
        class literal_pattern_expression : public pattern_expression {
        public:
            /**
             * Constructs a new literal pattern expression object
             * @param value Literal value
             */
            literal_pattern_expression(token value);
            /**
             * Destroys the expression object
             */
            ~literal_pattern_expression();
            /**
             * @return Literal value
             */
            token& value() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<ast::expression> clone() const 
            { 
                auto result = create<literal_pattern_expression>(value_);
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::literal_pattern_expression; } 
        private:
            /**
             * Literal value
             */
            mutable token value_;
        };
        /**
         * A tuple pattern is useful both for comparing and destructuring. 
         * Here's an example
         * `when expr {
         *     (1, 3, 2) => ...
         *     (single) => ...
         *     (_, 1, _) => ...
         * }`
         * the first pattern is a pure compare, the second is a compare and destructuring into
         * variable `single`, while the third is a comparing with ignoring first and third value.
         */
        class tuple_pattern_expression : public pattern_expression {
        public:
            /**
             * Constructs a new tuple pattern expression object
             * @param range Range of source code
             * @param elements Tuple elements patterns
             */
            tuple_pattern_expression(source_range range, pointers<ast::expression> elements);
            /**
             * Destroys the expression object
             */
            ~tuple_pattern_expression();
            /**
             * @return Elements patterns
             */
            pointers<ast::expression>& elements() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<ast::expression> clone() const 
            { 
                auto result = create<tuple_pattern_expression>(range_, ast::clone(elements_));
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::tuple_pattern_expression; } 
        private:
            /**
             * Elements patterns
             */
            mutable pointers<ast::expression> elements_;
        };
        /**
         * An array pattern is useful both for comparing and destructuring. 
         * Here's an example
         * `when expr {
         *     [1, 3, 2] => ...
         *     [single] => ...
         *     [_, 1, _] => ...
         * }`
         * the first pattern is a pure compare, the second is a compare and destructuring into
         * variable `single`, while the third is a comparing with ignoring first and third value.
         */
        class array_pattern_expression : public pattern_expression {
        public:
            /**
             * Constructs a new array pattern expression object
             * @param range Range of source code
             * @param elements Tuple elements patterns
             */
            array_pattern_expression(source_range range, pointers<ast::expression> elements);
            /**
             * Destroys the expression object
             */
            ~array_pattern_expression();
            /**
             * @return Elements patterns
             */
            pointers<ast::expression>& elements() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<ast::expression> clone() const 
            { 
                auto result = create<array_pattern_expression>(range_, ast::clone(elements_));
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::array_pattern_expression; } 
        private:
            /**
             * Elements patterns
             */
            mutable pointers<ast::expression> elements_;
        };
        /**
         * A record pattern expression is either a compare for variant kind
         * and fields destructuring. For example
         * `when expr {
         *     None() => ...
         *     Just(value) => ...
         * }`
         * here we have both variant kind comparing (expr is a Maybe type) and both
         * destructuring into `value` variable in the second case, while the first
         * case is an identifier pattern.
         */
        class record_pattern_expression : public pattern_expression {
        public:
            /**
             * Constructs a new record pattern expression object
             * @param range Range of source code
             * @param path Path name of type (eventually fully qualified)
             * @param fields Fields patterns, if any
             */
            record_pattern_expression(source_range range, ast::pointer<ast::expression> path, pointers<ast::expression> fields);
            /**
             * Destroys the expression object
             */
            ~record_pattern_expression();
            /**
             * @return Path name of record type
             */
            ast::pointer<ast::expression>& path() const;
            /**
             * @return Fields patterns
             */
            pointers<ast::expression>& fields() const;
            /**
             * @return true If it has no fields and no `()`
             * @return false Otherwise
             */
            bool is_path() const;
            /**
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<ast::expression> clone() const 
            { 
                auto result = create<record_pattern_expression>(range_, path_->clone(), ast::clone(fields_));
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::record_pattern_expression; } 
        private:
            /**
             * Record path name
             */
            mutable ast::pointer<ast::expression> path_;
            /**
             * Fields patterns
             */
            mutable pointers<ast::expression> fields_;
        };
        /**
         * A record pattern expression is either a compare for variant kind
         * and fields destructuring. For example
         * `when expr {
         *     None() => ...
         *     Just(some: value) => ...
         * }`
         * here we have both variant kind comparing (expr is a Maybe type) and both
         * destructuring into `value` variable in the second case, while the first
         * case is an identifier pattern.
         */
        class labeled_record_pattern_expression : public pattern_expression {
        public:
            /**
             * Field initializer
             */
            struct initializer {
                /**
                 * Field name
                 */
                token field;
                /**
                 * Field value
                 */
                pointer<ast::expression> value;
                /**
                 * Constructs a new  fieldinitializer object
                 * @param field Name of the field
                 * @param value Value of the field
                 */
                initializer(token field, pointer<ast::expression> value) : field(field), value(value) {}
            };
            /**
             * Constructs a new record pattern expression object
             * @param range Range of source code
             * @param path Path name of type (eventually fully qualified)
             * @param fields Fields patterns, if any
             */
            labeled_record_pattern_expression(source_range range, ast::pointer<ast::expression> path, std::vector<initializer> fields);
            /**
             * Destroys the expression object
             */
            ~labeled_record_pattern_expression();
            /**
             * @return Path name of record type
             */
            ast::pointer<ast::expression>& path() const;
            /**
             * @return Fields patterns
             */
            std::vector<initializer>& fields() const;
            /**
             * @return true If it has no fields and no `()`
             * @return false Otherwise
             */
            bool is_path() const;
            /**
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<ast::expression> clone() const 
            {
                std::vector<initializer> fields;
                for (auto field : fields_) fields.emplace_back(field.field, field.value->clone());
                auto result = create<labeled_record_pattern_expression>(range_, path_->clone(), fields);
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::labeled_record_pattern_expression; } 
        private:
            /**
             * Record path name
             */
            mutable ast::pointer<ast::expression> path_;
            /**
             * Fields patterns
             */
            mutable std::vector<initializer> fields_;
        };
        /**
         * Range patterns is useful to find out if an expression falls into a range.
         * For example
         * `when value {
         *     ..10 => println("less than 10")
         *     10 => println("10")
         *     11..=100 => println("between 11 and 100")
         * }`
         * where `..` is an open range like [begin, end), `..=` is a closed
         * range like [begin, end]
         */
        class range_pattern_expression : public pattern_expression {
        public:
            /**
             * Constructs a new range pattern expression object
             * @param range Range of source code
             * @param op Range operator (`..`, `..=`)
             * @param start Range start
             * @param end End start
             */
            range_pattern_expression(source_range range, token op, pointer<ast::expression> start, pointer<ast::expression> end);
            /**
             * Destroys the expression object
             */
            ~range_pattern_expression();
            /**
             * @return Range operator (`..`, `..=`)
             */
            token& range_operator() const;
            /**
             * @return Start expression
             */
            pointer<ast::expression>& start() const;
            /**
             * @return End expression
             */
            pointer<ast::expression>& end() const;
            /**
             * @return true If has operator `..=`
             */
            bool is_inclusive() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<ast::expression> clone() const 
            { 
                auto result = create<range_pattern_expression>(range_, range_operator_, start_ ? start_->clone() : nullptr, end_ ? end_->clone() : nullptr);
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::range_pattern_expression; } 
        private:
            /**
             * Range operator
             */
            mutable token range_operator_;
            /**
             * Range start
             */
            mutable pointer<ast::expression> start_;
            /**
             * Range end
             */
            mutable pointer<ast::expression> end_;
        };
        /**
         * Or pattern is used to chain alternative patterns to have a common action, for example
         * `when expr {
         *     1 | 2 | 10..=20 {...}
         * }`
         * where first branch is taken if the expression has value 1, 2 or it falls into range [10, 20]
         */
        class or_pattern_expression : public pattern_expression {
        public:
            /**
             * Constructs a new or pattern expression object
             * @param range Range in source code
             * @param op Or operator (`|`)
             * @param left Left expression
             * @param right Right expression
             */
            or_pattern_expression(source_range range, token op, pointer<ast::expression> left, pointer<ast::expression> right);
            /**
             * Destroys the expression object
             */
            ~or_pattern_expression();
            /**
             * @return Or operator (`|`)
             */
            token& or_operator() const;
            /**
             * @return Left expression
             */
            pointer<ast::expression>& left() const;
            /**
             * @return Right expression
             */
            pointer<ast::expression>& right() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<ast::expression> clone() const 
            { 
                auto result = create<or_pattern_expression>(range_, or_operator_, left_->clone(), right_->clone());
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::or_pattern_expression; } 
        private:
            /**
             * Or operator
             */
            mutable token or_operator_;
            /**
             * Left expression
             */
            mutable pointer<ast::expression> left_;
            /**
             * Right expression
             */
            mutable pointer<ast::expression> right_;
        };
        /**
         * Is pattern is used for type conversions in variants, for example
         * `when expr {
         *     is i32 => ...
         *     is string => ...
         * }`
         * where automatic cast is performed inside branches
         */
        class cast_pattern_expression : public pattern_expression {
        public:
            /**
             * Constructs a new cast pattern expression object
             * @param range Range in source code
             * @param type Type expression
             */
            cast_pattern_expression(source_range range, pointer<ast::expression> type);
            /**
             * Destroys the expression object
             */
            ~cast_pattern_expression();
            /**
             * @return Left expression
             */
            pointer<ast::expression>& type_expression() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<ast::expression> clone() const 
            { 
                auto result = create<cast_pattern_expression>(range_, type_expr_->clone());
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::cast_pattern_expression; } 
        private:
            /**
             * Left expression
             */
            mutable pointer<ast::expression> type_expr_;
        };
        /**
         * when expression is used for pattern matching, for example
         * `when value {
         *     1 => ...
         *     2 | 3 | 4 => ...
         *     100..200 => ...
         *     [1, _, num, ...] => ...
         *     (a, b, c) => ...
         *     Type(a, b, ...) => ...
         *     other => ...
         * }`
         * it has eventually an else body executed if there is no
         * match inside the when block.
         */
        class when_expression : public ast::expression {
        public:
            /**
             * A branch is a couple of pattern and action body
             */
            class branch {
            public:
                /**
                 * Constructs a new branch object
                 * @param pattern pattern expression
                 * @param body Action body
                 */
                branch(pointer<ast::expression> pattern, pointer<ast::expression> body);
                /**
                 * Destroys the branch object
                 */
                ~branch();
                /**
                 * @return pattern expression
                 */
                pointer<ast::expression>& pattern() const;
                /**
                 * @return Action body
                 */
                pointer<ast::expression>& body() const;
            private:
                /**
                 * pattern expression
                 */
                mutable pointer<ast::expression> pattern_;
                /**
                 * Action body expression
                 */
                mutable pointer<ast::expression> body_;
            };
            /**
             * Constructs a new when expression object
             * @param range Range in source code 
             * @param cond Tested condition
             * @param branches Branches
             * @param else_body Else body, eventually
             */
            when_expression(source_range range, pointer<ast::expression> cond, std::vector<branch> branches, pointer<ast::expression> else_body);
            /**
             * Destroys the expression object
             */
            ~when_expression();
            /**
             * @return Tested condition
             */
            pointer<ast::expression>& condition() const;
            /**
             * @return Branches for whenion
             */
            std::vector<branch>& branches() const;
            /**
             * @return Else body, if any
             */
            pointer<ast::expression>& else_body() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<ast::expression> clone() const 
            { 
                std::vector<branch> branches;
                for (auto branch : branches_) branches.emplace_back(branch.pattern()->clone(), branch.body()->clone());
                auto result = create<when_expression>(range_, condition_->clone(), branches, else_body_ ? else_body_->clone() : nullptr);
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::when_expression; } 
        private:
            /**
             * Tested condition
             */
            mutable pointer<ast::expression> condition_;
            /**
             * Branches
             */
            mutable std::vector<branch> branches_;
            /**
             * Else body
             */
            mutable pointer<ast::expression> else_body_;
        };
        /**
         * When pattern expression is used for pattern matching against one case, for example
         * `val result: none | some(T) = compute()
         * // destructuring
         * when result = some(value) {
         *     println("value")
         * }
         */
        class when_pattern_expression : public ast::expression {
        public:
            /**
             * Constructs a new when pattern expression object
             * @param range Range in source code 
             * @param cond Tested condition
             * @param pattern Pattern
             * @param body Body
             * @param else_body Else body, eventually
             */
            when_pattern_expression(source_range range, pointer<ast::expression> cond, pointer<ast::expression> pattern, pointer<ast::expression> body, pointer<ast::expression> else_body);
            /**
             * Destroys the expression object
             */
            ~when_pattern_expression();
            /**
             * @return Tested condition
             */
            pointer<ast::expression>& condition() const;
            /**
             * @return Pattern
             */
            pointer<ast::expression>& pattern() const;
            /**
             * @return Body
             */
            pointer<ast::expression>& body() const;
            /**
             * @return Else body, if any
             */
            pointer<ast::expression>& else_body() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<ast::expression> clone() const 
            { 
                auto result = create<when_pattern_expression>(range_, condition_->clone(), pattern_->clone(), body_->clone(), else_body_ ? else_body_->clone() : nullptr); 
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::when_pattern_expression; } 
        private:
            /**
             * Tested condition
             */
            mutable pointer<ast::expression> condition_;
            /**
             * Pattern
             */
            mutable pointer<ast::expression> pattern_;
            /**
             * Body
             */
            mutable pointer<ast::expression> body_;
            /**
             * Else body
             */
            mutable pointer<ast::expression> else_body_;
        };
        /**
         * When cast expression is used for automatic cast inside block, for example
         * val result: none | T = compute()
         * // automatic cast to T
         * when result is T {
         *     // result is automatically casted to T
         *     println("value is {result}")
         * }
         */
        class when_cast_expression : public ast::expression {
        public:
            /**
             * Constructs a new when pattern expression object
             * @param range Range in source code 
             * @param cond Tested condition
             * @param type Type expression
             * @param body Body
             * @param else_body Else body, eventually
             */
            when_cast_expression(source_range range, pointer<ast::expression> cond, pointer<ast::expression> type_expr, pointer<ast::expression> body, pointer<ast::expression> else_body);
            /**
             * Destroys the expression object
             */
            ~when_cast_expression();
            /**
             * @return Tested condition
             */
            pointer<ast::expression>& condition() const;
            /**
             * @return Type expression
             */
            pointer<ast::expression>& type_expression() const;
            /**
             * @return Body
             */
            pointer<ast::expression>& body() const;
            /**
             * @return Else body, if any
             */
            pointer<ast::expression>& else_body() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<ast::expression> clone() const 
            { 
                auto result = create<when_cast_expression>(range_, condition_->clone(), type_expr_->clone(), body_->clone(), else_body_ ? else_body_->clone() : nullptr); 
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::when_cast_expression; } 
        private:
            /**
             * Tested condition
             */
            mutable pointer<ast::expression> condition_;
            /**
             * Pattern
             */
            mutable pointer<ast::expression> type_expr_;
            /**
             * Body
             */
            mutable pointer<ast::expression> body_;
            /**
             * Else body
             */
            mutable pointer<ast::expression> else_body_;
        };
        /**
         * For range is used to iterate through a sequence of elements. Here's an example
         * `for item: int in 1..=100 {
         *     println("item = {item}")
         * }`
         * Else body, if any, is executed when all the elements are exhasted and there is no explicit
         * exit from the cycle.
         * It is possible to return a value from an iteration with `break` like this
         * `val result = for i in 0..array.length {
         *     if array[i] == key => break i
         * }`
         * which simulates a linear search
         */
        class for_range_expression : public ast::expression {
        public:
            /**
             * Constructs a new for range expression object
             * @param range Range of source code 
             * @param var Iteration variable
             * @param condition Condition, which must be an iterable sequence
             * @param body Body
             * @param else_body Else body, if any 
             * @param contracts List of contract statements
             */
            for_range_expression(source_range range, pointer<ast::declaration> var, pointer<ast::expression> condition, pointer<ast::expression> body, pointer<ast::expression> else_body, pointers<ast::statement> contracts);
            /**
             * Destroys the for range expression object
             */
            ~for_range_expression();
            /**
             * @return Iteration variable
             */
            pointer<ast::declaration> variable() const;
            /**
             * @return Condition expression, which must be an iterable sequence
             */
            pointer<ast::expression>& condition() const;
            /**
             * @return Body
             */
            pointer<ast::expression>& body() const;
            /**
             * @return Else body, if any
             */
            pointer<ast::expression>& else_body() const;
            /**
             * @return List of contract statements
             */
            pointers<ast::statement>& contracts() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<ast::expression> clone() const 
            { 
                auto result = create<for_range_expression>(range_, var_->clone(), condition_->clone(), body_ ? body_->clone() : nullptr, else_body_ ? else_body_->clone() : nullptr, ast::clone(contracts_));
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::for_range_expression; } 
        private:
            /**
             * Iteration variable declaration
             */
            pointer<ast::declaration> var_;
            /**
             * Condition expression
             */
            mutable pointer<ast::expression> condition_;
            /**
             * Body
             */
            mutable pointer<ast::expression> body_;
            /**
             * Elese body
             */
            mutable pointer<ast::expression> else_body_;
            /**
             * List of contract statements
             */
            mutable pointers<ast::statement> contracts_;
        };
        /**
         * For loop is used simulates C while. Here's an example
         * `for i < 10 {
         *     println("i = {i++}")
         * }`
         * If no condition is present, like `for {...}` then it is a forever loop
         * Else body, if any, is executed when all the elements are exhasted and there is no explicit
         * exit from the cycle.
         * It is possible to return a value from a cycle with `break` like this
         * `val result = for i < 10 {
         *     if f() => break res
         *     ...
         * }`
         */
        class for_loop_expression : public ast::expression {
        public:
            /**
             * Constructs a new for loop expression object
             * @param range Range of source code
             * @param condition Condition expression, if any
             * @param body Body
             * @param else_body Else body 
             * @param contracts List of contract statements
             */
            for_loop_expression(source_range range, pointer<ast::expression> condition, pointer<ast::expression> body, pointer<ast::expression> else_body, pointers<ast::statement> contracts);
            /**
             * Destroys the expression object
             */
            ~for_loop_expression();
            /**
             * @return Condition expression, if any
             */
            pointer<ast::expression>& condition() const;
            /**
             * @return Body
             */
            pointer<ast::expression>& body() const;
            /**
             * @return Else body, if any
             */
            pointer<ast::expression>& else_body() const;
            /**
             * @return List of contract statements
             */
            pointers<ast::statement>& contracts() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<ast::expression> clone() const 
            { 
                auto result = create<for_loop_expression>(range_, condition_ ? condition_->clone() : nullptr, body_ ? body_->clone() : nullptr, else_body_ ? else_body_->clone() : nullptr, ast::clone(contracts_)); 
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::for_loop_expression; } 
        private:
            /**
             * Condition expression
             */
            mutable pointer<ast::expression> condition_;
            /**
             * Body
             */
            mutable pointer<ast::expression> body_;
            /**
             * Else body
             */
            mutable pointer<ast::expression> else_body_;
            /**
             * List of contract statements
             */
            mutable pointers<ast::statement> contracts_;
        };
        /**
         * Classic if, with the notable improvement that it can be an expression.
         * Here's an example
         * `val result = if name == "John Wick" { "assassin"s } else { "civil"s }
         */
        class if_expression : public ast::expression {
        public:
            /**
             * Constructs a new if expression object
             * @param range Range in source code
             * @param condition Condition expression
             * @param body Then body
             * @param else_body Else body, if any
             */
            if_expression(source_range range, pointer<ast::expression> condition, pointer<ast::expression> body, pointer<ast::expression> else_body);
            /**
             * Destroys the expression object
             */
            ~if_expression();
            /**
             * @return Condition expression
             */
            pointer<ast::expression>& condition() const;
            /**
             * @return Then body
             */
            pointer<ast::expression>& body() const;
            /**
             * @return Else body, if any
             */
            pointer<ast::expression>& else_body() const;
            /**
             * @return false Always
             */
            bool is_path() const;
            /**
             * @return false Always
             */
            bool is_assignable() const;
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const;
            /**
             * Clone an expression
             */
            pointer<ast::expression> clone() const 
            { 
                auto result = create<if_expression>(range_, condition_ ? condition_->clone() : nullptr, body_ ? body_->clone() : nullptr, else_body_ ? else_body_->clone() : nullptr);
                result->annotation_ = annotation_;
                return result;
            }
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::if_expression; } 
        private:
            /**
             * Condition expression
             */
            mutable pointer<ast::expression> condition_;
            /**
             * Then body
             */
            mutable pointer<ast::expression> body_;
            /**
             * Else body
             */
            mutable pointer<ast::expression> else_body_;
        };
        /**
         * A workspace is a collection of source files which shares the same
         * name declarations. A workspace is similar to a Java package. Files
         * who share the same workspace must have the same workspace directory
         * and reside in the same directory. A workspace is a child of another
         * if it resides in a subdirectory of the parent and its prefix is the
         * same of the parent.
         * For example `a.b` is child of `a` if `b` is a subdirectory of `a`.
         * So `.` in path notation is replaced with `/` for files or directories.
         */
        struct workspace : public declaration {
            /**
             * Full name of the workspace, for example `math`
             */
            std::string name;
            /**
             * Name of the package to which it belongs, a package is a node, for example `math@1.0.1`, which is package `math` at version `1.0.1`
             */
            std::string package;
            /**
             * workspace type
             */
            ast::pointer<ast::type> type;
            /**
             * Imported workspacees
             */
            std::unordered_map<std::string, workspace*> imports;
            /**
             * Source files associated
             */
            std::unordered_map<std::string, source_file*> sources;
            /**
             * Instantiated generics
             */
            std::unordered_map<std::string, pointer<type_declaration>> instantiated;
            /**
             * Instantiated generic functions
             */
            std::unordered_map<std::string, pointer<function_declaration>> instantiated_functions;
            /**
             * Result of verification of concept with concrete arguments
             */
            std::unordered_map<std::string, bool> tested_concept;
            /**
             * Generics type extensions
             */
            ast::pointers<ast::declaration> textensions;
            /**
             * Saved declarations, for shared_ptr existence
             */
            ast::pointers<ast::declaration> saved;
            /**
             * List of all processed types, including:
             * [*] the ones declared with a name
             * [*] anonymous types which needs construction, like anonymous struct, tuple or variant
             * They are added in the same order in which are resolved, so code generator can emit code correcly
             */
            ast::pointers<ast::type> types;
            /**
             * List of all non-associated function declarations
             */
            std::vector<const ast::function_declaration*> functions;
            /**
             * List of global variables and constants' declarations
             */
            std::vector<const ast::declaration*> globals;
            /**
             * List of all function expression used to extract their lambda type so it could be instantiated, mapped to their id in C++
             */
            std::unordered_map<const ast::function_expression*, std::size_t> lambdas;
            /**
             * Tells if workspace is builtin
             */
            bool builtin = false;
            /**
             * Default constructor
             */
            workspace() : declaration(source_range()), name("__null") {}
            /**
             * Constructor with name
             * @param name workspace name
             */
            workspace(const std::string& name) : declaration(source_range()), name(name) {}
            /**
             * Constructor with name
             * @param name Workspace name
             * @param package Package name
             */
            workspace(const std::string& name, const std::string& package) : declaration(source_range()), name(name), package(package) {}
            /**
             * Clone
             */
            pointer<declaration> clone() const { return nullptr; }
            /**
             * Accepts a visitor for traversal
             * @param visitor Generic visitor
             */
            void accept(visitor& visitor) const {}
            /**
             * @return Node kind
             */
            ast::kind kind() const { return kind::workspace; } 
        };
        /**
         * Base class for AST traversal, contains all method to traverse a
         * particular node of the abstract syntax tree
         */
        struct visitor {
            virtual void visit(const bit_field_type_expression& expr) {}
            virtual void visit(const path_type_expression& expr) {}
            virtual void visit(const array_type_expression& expr) {}
            virtual void visit(const tuple_type_expression& expr) {}
            virtual void visit(const pointer_type_expression& expr) {}
            virtual void visit(const function_type_expression& expr) {}
            virtual void visit(const record_type_expression& expr) {}
            virtual void visit(const variant_type_expression& expr) {}
            virtual void visit(const literal_expression& expr) {}
            virtual void visit(const identifier_expression& expr) {}
            virtual void visit(const tuple_expression& expr) {}
            virtual void visit(const array_expression& expr) {}
            virtual void visit(const array_sized_expression& expr) {}
            virtual void visit(const parenthesis_expression& expr) {}
            virtual void visit(const block_expression& expr) {}
            virtual void visit(const function_expression& expr) {}
            virtual void visit(const postfix_expression& expr) {}
            virtual void visit(const call_expression& expr) {}
            virtual void visit(const member_expression& expr) {}
            virtual void visit(const array_index_expression& expr) {}
            virtual void visit(const tuple_index_expression& expr) {}
            virtual void visit(const record_expression& expr) {}
            virtual void visit(const unary_expression& expr) {}
            virtual void visit(const binary_expression& expr) {}
            virtual void visit(const implicit_conversion_expression& expr) {}
            virtual void visit(const range_expression& expr) {}
            virtual void visit(const ignore_pattern_expression& expr) {}
            virtual void visit(const literal_pattern_expression& expr) {}
            virtual void visit(const path_pattern_expression& expr) {}
            virtual void visit(const tuple_pattern_expression& expr) {}
            virtual void visit(const array_pattern_expression& expr) {}
            virtual void visit(const record_pattern_expression& expr) {}
            virtual void visit(const labeled_record_pattern_expression& expr) {}
            virtual void visit(const range_pattern_expression& expr) {}
            virtual void visit(const or_pattern_expression& expr) {}
            virtual void visit(const cast_pattern_expression& expr) {}
            virtual void visit(const when_expression& expr) {}
            virtual void visit(const when_pattern_expression& expr) {}
            virtual void visit(const when_cast_expression& expr) {}
            virtual void visit(const for_range_expression& expr) {}
            virtual void visit(const for_loop_expression& expr) {}
            virtual void visit(const if_expression& expr) {}
            virtual void visit(const null_statement& stmt) {}
            virtual void visit(const expression_statement& stmt) {}
            virtual void visit(const assignment_statement& stmt) {}
            virtual void visit(const later_statement& stmt) {}
            virtual void visit(const return_statement& stmt) {}
            virtual void visit(const break_statement& stmt) {}
            virtual void visit(const continue_statement& stmt) {}
            virtual void visit(const contract_statement& stmt) {}
            virtual void visit(const field_declaration& decl) {}
            virtual void visit(const tuple_field_declaration& decl) {}
            virtual void visit(const parameter_declaration& decl) {}
            virtual void visit(const var_declaration& decl) {}
            virtual void visit(const var_tupled_declaration& decl) {}
            virtual void visit(const const_declaration& decl) {}
            virtual void visit(const const_tupled_declaration& decl) {}
            virtual void visit(const generic_clause_declaration& decl) {}
            virtual void visit(const generic_const_parameter_declaration& decl) {}
            virtual void visit(const generic_type_parameter_declaration& decl) {}
            virtual void visit(const test_declaration& decl) {}
            virtual void visit(const function_declaration& decl) {}
            virtual void visit(const property_declaration& decl) {}
            virtual void visit(const concept_declaration& decl) {}
            virtual void visit(const extend_declaration& decl) {}
            virtual void visit(const behaviour_declaration& decl) {}
            virtual void visit(const extern_declaration& decl) {}
            virtual void visit(const range_declaration& decl) {}
            virtual void visit(const record_declaration& decl) {}
            virtual void visit(const variant_declaration& decl) {}
            virtual void visit(const alias_declaration& decl) {}
            virtual void visit(const use_declaration& decl) {}
            virtual void visit(const workspace_declaration& decl) {}
            virtual void visit(const source_unit_declaration& decl) {}
        };
        /**
         * Abstract syntax tree printer
         */
        class printer : public visitor {
        public:
            printer() = default;
            virtual void visit(const bit_field_type_expression& expr);
            virtual void visit(const path_type_expression& expr);
            virtual void visit(const array_type_expression& expr);
            virtual void visit(const tuple_type_expression& expr);
            virtual void visit(const pointer_type_expression& expr);
            virtual void visit(const function_type_expression& expr);
            virtual void visit(const record_type_expression& expr);
            virtual void visit(const variant_type_expression& expr);
            virtual void visit(const literal_expression& expr);
            virtual void visit(const identifier_expression& expr);
            virtual void visit(const tuple_expression& expr);
            virtual void visit(const array_expression& expr);
            virtual void visit(const array_sized_expression& expr);
            virtual void visit(const parenthesis_expression& expr);
            virtual void visit(const block_expression& expr);
            virtual void visit(const function_expression& expr);
            virtual void visit(const postfix_expression& expr);
            virtual void visit(const call_expression& expr);
            virtual void visit(const member_expression& expr);
            virtual void visit(const array_index_expression& expr);
            virtual void visit(const tuple_index_expression& expr);
            virtual void visit(const record_expression& expr);
            virtual void visit(const unary_expression& expr);
            virtual void visit(const binary_expression& expr);
            virtual void visit(const implicit_conversion_expression& expr);
            virtual void visit(const range_expression& expr);
            virtual void visit(const ignore_pattern_expression& expr);
            virtual void visit(const literal_pattern_expression& expr);
            virtual void visit(const path_pattern_expression& expr);
            virtual void visit(const tuple_pattern_expression& expr);
            virtual void visit(const array_pattern_expression& expr);
            virtual void visit(const record_pattern_expression& expr);
            virtual void visit(const labeled_record_pattern_expression& expr);
            virtual void visit(const range_pattern_expression& expr);
            virtual void visit(const or_pattern_expression& expr);
            virtual void visit(const cast_pattern_expression& expr);
            virtual void visit(const when_expression& expr);
            virtual void visit(const when_pattern_expression& expr);
            virtual void visit(const when_cast_expression& expr);
            virtual void visit(const for_range_expression& expr);
            virtual void visit(const for_loop_expression& expr);
            virtual void visit(const if_expression& expr);
            virtual void visit(const null_statement& stmt);
            virtual void visit(const expression_statement& stmt);
            virtual void visit(const assignment_statement& stmt);
            virtual void visit(const later_statement& stmt);
            virtual void visit(const return_statement& stmt);
            virtual void visit(const break_statement& stmt);
            virtual void visit(const continue_statement& stmt);
            virtual void visit(const contract_statement& stmt);
            virtual void visit(const field_declaration& decl);
            virtual void visit(const tuple_field_declaration& decl);
            virtual void visit(const parameter_declaration& decl);
            virtual void visit(const var_declaration& decl);
            virtual void visit(const var_tupled_declaration& decl);
            virtual void visit(const const_declaration& decl);
            virtual void visit(const const_tupled_declaration& decl);
            virtual void visit(const generic_clause_declaration& decl);
            virtual void visit(const generic_const_parameter_declaration& decl);
            virtual void visit(const generic_type_parameter_declaration& decl);
            virtual void visit(const test_declaration& decl);
            virtual void visit(const function_declaration& decl);
            virtual void visit(const property_declaration& decl);
            virtual void visit(const concept_declaration& decl);
            virtual void visit(const extend_declaration& decl);
            virtual void visit(const behaviour_declaration& decl);
            virtual void visit(const extern_declaration& decl);
            virtual void visit(const range_declaration& decl);
            virtual void visit(const record_declaration& decl);
            virtual void visit(const variant_declaration& decl);
            virtual void visit(const alias_declaration& decl);
            virtual void visit(const use_declaration& decl);
            virtual void visit(const workspace_declaration& decl);
            virtual void visit(const source_unit_declaration& decl);
            /**
             * Starts printing a statement
             * @param stmt Statement
             * @return All AST printed inside a string
             */
            std::string print(const statement& stmt);
            /**
             * Starts printing an expression
             * @param expe Expression
             * @return All AST printed inside a string
             */
            std::string print(const expression& expr);
        private:
            /**
             * A prefix is used for indenting the printed tree 
             */
            class prefix {
            public:
                prefix() = default;
                /**
                 * Sets the prefix as last child to print flag
                 * @param last Last child flag
                 */
                void top(bool last);
                /**
                 * Pushes a prefix on the stack
                 * @param last Last child flag
                 */
                void push(bool last);
                /**
                 * Pops last prefix, if any
                 */
                void pop();
                /**
                 * Creates a prefix for a node printing after indenting
                 * @param node Node
                 * @return Formatted string
                 */
                std::string str(const ast::node& node) const;
                /**
                 * Creates a prefix for a declaration printing after indenting
                 * @param node Node
                 * @return Formatted string
                 */
                std::string str(const ast::declaration& decl) const;
            private:
                /**
                 * Stack of last flags
                 */
                std::list<bool> lasts_;
            };
            /**
             * Prefixes as a stack
             */
            prefix prefix_;
            /**
             * Output string stream
             */
            std::ostringstream stream_;
        };
    }
}

bool operator==(const nemesis::constval& l, const nemesis::constval& r);
std::ostream& operator<<(std::ostream& os, nemesis::constval val);

#endif // AST_HPP